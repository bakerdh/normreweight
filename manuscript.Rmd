---
title: 'Temporal Dynamics of Normalization Reweighting'
author: | 
  | Daniel H. Baker, Daniela Marinova, Richard Aveyard, Lydia J. Hargreaves, Alice Renton,  
  | Ruby Castellani, Phoebe Hall, Miriam Harmens, Georgia Holroyd, Beth Nicholson, 
  | Emily L. Williams, Hannah M. Hobson & Alex R. Wade
date: "`r Sys.Date()`"
output:
  bookdown::pdf_document2:
    fig_caption: yes
    toc: no
    keep_tex: yes
  word_document: default
  pdf_document:
    toc: no
  html_document: default
bibliography: references.bib
csl: elife.csl
---

```{r setup, include=FALSE}

processdata <- 0  # this flag determines the amount of processing, with 4 levels:
# 0 - do no processing, generate the pdf using existing versions of all figures
# 1 - generate figures using the processed group data (requires XGB of storage)
# 2 - download processed individual data and analyse (requires XGB of storage)
# 3 - download all raw data and analyse (requires 78+GB of storage)

plotsmoothed <- 1 # either plot the raw data (0), or a smoothed spline (1)
useSPQ <- 0  # optionally do the median split by SPQ for the main EEG experiment

# reasonably compact code to check which packages are installed, install the missing ones, and activate all
packagelist <- c('knitr','remotes','tictoc','R.matlab','bookdown','rmarkdown','grImport','tiff','pals','ez','gtools','pracma') # list of CRAN packages
missingpackages <- packagelist[!packagelist %in% installed.packages()[,1]]
if (length(missingpackages)>0){install.packages(missingpackages)}
if (!'osfr' %in% installed.packages()[,1]){remotes::install_github("centerforopenscience/osfr")}
if (!'FourierStats' %in% installed.packages()[,1]){remotes::install_github("bakerdh/FourierStats")}
packagelist <- c(packagelist,'osfr','FourierStats')
toinstall <- packagelist[which(!packagelist %in% (.packages()))]
invisible(lapply(toinstall,library,character.only=TRUE))

# helper function to make colours transparent
addalpha <- function(col, alpha=1){apply(sapply(col, col2rgb)/255, 2, function(x) rgb(x[1], x[2], x[3], alpha=alpha))}

v4Interp <- function(df, xo, yo, rmax = .75, gridRes = 67) {
  ## Create a function to perform Matlab's v4 interpolation.
  ## Takes as input a data-frame with columns x, y, and z (x co-ordinates, y co-ordinates, and amplitude)
  ## and variables xo and yo, the co-ordinates which will be use to create a grid for interpolation
  xo <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
  yo <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
  xy <- df$x + df$y*sqrt(as.complex(-1))
  d <- matrix(rep(xy,length(xy)),nrow = length(xy), ncol = length(xy))
  d <- abs(d - t(d))
  diag(d) <- 1
  g <- (d^2) * (log(d)-1)   # Green's function.
  diag(g) <- 0
  weights <- qr.solve(g,df$z)
  xy <- t(xy)
  outmat <- matrix(nrow = gridRes,ncol = gridRes)
  for (i in 1:gridRes){
    for (j in 1:gridRes) {
      test4 <- abs((xo[i,j] + sqrt(as.complex(-1))*yo[i,j]) - xy)
      g <- (test4^2) * (log(test4)-1)
      outmat[i,j] <- g %*% weights}}
  outDf <- data.frame(x = xo[,1],outmat)
  names(outDf)[1:length(yo[1,])+1] <- yo[1,]
  return(outDf)}

scoreAQ <- function(qdata){
# score the AQ questionnaire
# input is a row from a spreadsheet indicating responses to 50 questions
AQanswers <- toupper(c('(1) Definitely agree','(2) Slightly agree', '(3) Slightly disagree', '(4) Definitely disagree'))
reverseitems <- rep(0,50)
 # reverse scored questionnaire items
reverseitems[c(3,8,10,11,14,15,17,24,25,27,28,29,30,31,32,34,36,37,38,40,44,47,48,49,50)] <- 1 

  thisAQ <- 0
  nansweredAQ <- 0
  for (q in 1:50){
    response <- which(AQanswers==toupper(as.character(qdata[1,q])))
    if (length(response)>0){
      nansweredAQ <- nansweredAQ + 1
      if (reverseitems[q]==0){response <- 5 - response}
      if (response>2){thisAQ <- thisAQ + 1}
    }}
thisAQ <- round(50*thisAQ/nansweredAQ)    
return(thisAQ)}

scoreAQshort <- function(qdata){
# score the AQ questionnaire - short version
# input is a row from a spreadsheet indicating responses to 28 questions
AQanswers <- toupper(c('(4) Definitely agree','(3) Slightly agree', '(2) Slightly disagree', '(1) Definitely disagree'))
reverseitems <- rep(1,28)
 # reverse scored questionnaire items
reverseitems[c(3,5,8,11,12,19,21,22,24,25,26,27,28)] <- 0

  thisAQ <- 0
  nansweredAQ <- 0
  for (q in 1:28){
    response <- which(AQanswers==toupper(as.character(qdata[1,q])))
    if (length(response)>0){
      nansweredAQ <- nansweredAQ + 1
      if (reverseitems[q]==0){response <- 5 - response}
      if (response>2){thisAQ <- thisAQ + 1}
    }}
thisAQ <- round(50*thisAQ/nansweredAQ)    
return(thisAQ)}

scoreSPQ <- function(qdata){
# score the SPQ questionnaire
# input is a row from a spreadsheet indicating responses to 92 questions
SPQanswers <- toupper(c('Strongly agree','Agree','Disagree','Strongly Disagree'))
# SPQorder <- c(4,2,1,3)
reverseitemsSPQ <- (1:ncol(qdata))*0
reverseitemsSPQ[c(3,4,5,10,13,15:18,20,22,25:29,31,34,39,40,42:44,46:48,51,54,56,57,63,66,67,72,75,77:80,86,89,92)] <- 1  # reverse scored questionnaire items

  thisSPQ <- 0
  nansweredSPQ <- 0
  for (q in 1:92){
    response <- which(SPQanswers==toupper(as.character(qdata[1,q]))) - 1
    if (length(response)>0){
      nansweredSPQ <- nansweredSPQ + 1
      if (reverseitemsSPQ[q]==1){response <- 3 - response}
      thisSPQ <- thisSPQ + response
    }
  }

return(thisSPQ)}


clustercorrect <- function(datax,datay=NULL,adjacencymatrix=NULL,testtype=1,paired=TRUE,clustformthresh=0.05,clustthresh=0.05,nresamples=10000) {
  clustout <- NULL
  sigclustercount <- 0
  clusterpout <- NULL
  clusterpoints <- list()
  nulldist <- NULL
  N <- nrow(datax)  # number of observations (e.g. participants)
  m <- ncol(datax)  # number of measurements (e.g. sensors, voxels, timepoints)

  # if complex data have been passed in and t-test selected, convert to amplitudes
  if (is.complex(datax) && testtype==1){datax <- abs(datax)}
  if (is.complex(datay) && testtype==1){datay <- abs(datay)}

  # if two data sets have been passed in, note the size of the second matrix
  if (!pracma::isempty(datay)){N2 <- nrow(datay)}

  # if it's a paired design, subtract the two data sets and delete the second one
  if (paired==TRUE && !pracma::isempty(datay)){
    datax <- datax - datay
    datay <- NULL}

  if (length(adjacencymatrix)==0){
    # if no adjacency matrix has been passed in, we assume that subsequent observations are adjacent
    adjacencymatrix <- matrix(0,nrow=m,ncol=m)
    for (n in 1:(m-1)){adjacencymatrix[n,n+1] <- 1}
    for (n in 2:m){adjacencymatrix[n,n-1] <- 1}
  }

  allp <- NULL
  allt <- NULL
  # loop through all elements (sensors/time points) and calculate the test statistic and p-value
  for (n in 1:m){

    if (pracma::isempty(datay)){
      # one-sample or paired test
      if (testtype==1){
        output <- t.test(datax[,n])  # univariate t-test
        allp[n] <- output$p.value
        allt[n] <- output$statistic}
      if (testtype==2){
        output <- tsqh.test(datax[,n])  # one-sample Hotelling's t-squared
        allp[n] <- output$pval
        allt[n] <- output$tsq}
      if (testtype==3){
        output <- tsqc.test(datax[,n])  # T-squared-circ
        allp[n] <- output$pval
        allt[n] <- output$tsqc}
      if (testtype==4){
        output <- t.test(datax[,n],alternative='greater')  # univariate t-test
        allp[n] <- output$p.value
        allt[n] <- output$statistic}
    }

    # independent samples test
    if (!pracma::isempty(datay) && is.matrix(datay)){
      if (testtype==1){
        output <- t.test(datax[,n],datay[,n]) # independent t-test
        allp[n] <- output$p.value
        allt[n] <- output$statistic}
      if (testtype==2){
        output <- tsqh.test(datax[,n],datay[,n],paired=FALSE)  # independent T-squared
        allp[n] <- output$pval
        allt[n] <- output$tsq}
      if (testtype==3){
        output <- tsqc.test(datax[,n],datay[,n],paired=FALSE)  # independent T-squared-circ
        allp[n] <- output$pval
        allt[n] <- output$tsqc}
            if (testtype==4){
        output <- t.test(datax[,n],datay[,n],alternative='greater') 
        allp[n] <- output$p.value
        allt[n] <- output$statistic}
    }
  }

  allp[which(is.na(allp))] <- 1

  # now generate a list of clusters of adjacent significant elements
  hvect <- rep(0,m)
  hvect[which(allp<clustformthresh)] <- 1
  hmat <- matrix(hvect,nrow=m,ncol=m)
  hmat2 <- hmat * t(hmat)
  clustprod <- hmat2 * adjacencymatrix

  clusterlist <- list()
  nclusts <- 0
  for (n in 1:m){
    temp = sum(clustprod[n,])
    if (temp>0){
      i <- which(clustprod[n,]>0)
      tempclust <- c(n, i)
      clustprod[n,] <- 0
      clustprod[,n] <- 0
      cnt <- 0
      while (cnt<length(tempclust)){
        cnt <- cnt + 1
        temp = sum(clustprod[tempclust[cnt],])
        if (temp>0){
          i <- which(clustprod[tempclust[cnt],]>0)
          tempclust <- c(tempclust, i)
          clustprod[tempclust[cnt],] <- 0
          clustprod[,tempclust[cnt]] <- 0
        }
      }
      nclusts <- nclusts + 1
      clusterlist[[nclusts]] <- sort(unique(tempclust))
    }
  }

  if (nclusts>0){
    sumtvals <- NULL
    for (cc in 1:nclusts){
      Cindices <- as.numeric(clusterlist[[cc]])
      sumtvals[cc] <- sum(allt[Cindices])}

    i <- which(sumtvals==max(sumtvals))  # find the largest cluster
    maxcluster <- clusterlist[[i]]  # store the largest cluster

    if (length(maxcluster)>1){
    # build a null distribution by permuting signs/group labels
    for (n in 1:nresamples){
      tsum <- 0
      if (pracma::isempty(datay)){randsigns <- (round(runif(N))*2)-1}
      if (!pracma::isempty(datay) && is.matrix(datay)){randgroups <- permute(c(1:N,(N+1):(N+N2)))}
      for (elcounter in 1:length(maxcluster)){

        if (pracma::isempty(datay)){  # one-sample or paired test
          tempdataA <- datax[,maxcluster[elcounter]]*randsigns
          if (testtype==1){
            output <- t.test(tempdataA)
            tsum <- tsum + output$statistic}
          if (testtype==2){
            output <- tsqh.test(tempdataA)
            tsum <- tsum + output$tsq}
          if (testtype==3){
            output <- tsqc.test(tempdataA)
            tsum <- tsum + output$tsqc}
        }

        if (!pracma::isempty(datay) && is.matrix(datay)){  # independent samples test
          tempdata <- c(datax[,maxcluster[elcounter]],datay[,maxcluster[elcounter]])
          tempdataA <- tempdata[randgroups[1:N]]
          tempdataB <- tempdata[randgroups[(N+1):(N+N2)]]
          if (testtype==1){
            output <- t.test(tempdataA,tempdataB)
            tsum <- tsum + output$statistic}
          if (testtype==2){
            output <- tsqh.test(tempdataA,tempdataB,paired=FALSE)
            tsum <- tsum + output$tsq}
          if (testtype==3){
            output <- tsqc.test(tempdataA,tempdataB,paired=FALSE)
            tsum <- tsum + output$tsqc}
        }
      }
      nulldist[n] <- tsum
    }
    }

    # compare each cluster to the null distribution, retain the significant ones
    clusterps <- 0*(1:nclusts)
    if (length(nulldist)==nresamples){
    for (cc in 1:nclusts){
      i <- which(abs(nulldist)>abs(sumtvals[cc]))
      if (!pracma::isempty(i)){clusterps[cc] <- length(i)/nresamples}
      if (clusterps[cc]<clustthresh){
        sigclustercount <- sigclustercount + 1
        clusterpoints[[sigclustercount]] <- clusterlist[[cc]]
        clusterpout[sigclustercount] <- clusterps[cc]
        }
    }}
  }
clustout <- NULL
clustout$clusterpoints <- clusterpoints
clustout$nclusters <- sigclustercount
clustout$pvals <- clusterpout

return(clustout)
}

knitr::opts_chunk$set(echo = TRUE)
colpal <- c('#000000','#8783CF','#FE5000','#228B22','#6d008b','#8B8000')

# check if directories exist to store data files (ignored by git)
if (!dir.exists('temp/')){dir.create('temp/')}
if (!dir.exists('temp/VilidaiteProcessed/')){dir.create('temp/VilidaiteProcessed/')}
if (!dir.exists('temp/raw/')){dir.create('temp/raw/')}
if (!dir.exists('temp/raw/temp/')){dir.create('temp/raw/temp/')}
if (!dir.exists('temp/MEGdata/')){dir.create('temp/MEGdata/')}
if (!dir.exists('temp/EEGprocessed/')){dir.create('temp/EEGprocessed/')}
if (!dir.exists('temp/pilotraw/')){dir.create('temp/pilotraw/')}
if (!dir.exists('temp/pilotraw/temp/')){dir.create('temp/pilotraw/temp/')}

targetelectrodes <- c('Oz','POz','O1','O2')

osfproject <- osf_retrieve_node("ab3yv")
componentlist <- osf_ls_nodes(osfproject)
osffiles <- osf_ls_files(osfproject,n_max=300)

pilotproject <- osf_retrieve_node("y4n5k")
pilotfiles <- osf_ls_files(pilotproject,n_max=300)
if (!file.exists('temp/headerfile.csv')){
  hid <- pmatch('headerfile.csv',as.character(unlist(pilotfiles[,1])))
  osf_download(pilotfiles[hid,], path='temp/')
}
hdata <- read.csv('temp/headerfile.csv')

nbootstraps <- 1000    # number of bootstrap resamples for cluster correction
timeoffset <- 1000  # time offset for determining if suppression is increasing


```

# Abstract

For decades, neural suppression in early visual cortex has been thought to be fixed. But recent work has challenged this assumption by showing that suppression can be \emph{reweighted} based on recent history; when pairs of stimuli are repeatedly presented together, suppression between them strengthens. Here we investigate the temporal dynamics of this process using a steady-state VEP paradigm that provides a time-resolved, direct index of suppression between pairs of stimuli flickering at different frequencies (5 and 7Hz). Our initial analysis of an existing EEG dataset (N=100) indicated that suppression increases substantially during the first 2-5 seconds of stimulus presentation (with some variation across stimulation frequency). We then collected new EEG data (N=100) replicating this finding for both monocular and dichoptic mask arrangements in a preregistered study designed to measure reweighting. A third experiment (N=20) used source localized MEG, and found that these effects are apparent in primary visual cortex (V1), consistent with results from neurophysiological work. Because long-standing theories propose inhibition/excitation differences in autism, we also compared reweighting between individuals with high vs low autistic traits, and with and without an autism diagnosis, across our 3 data sets (total N=220). We find no compelling differences in reweighting that are associated with autism. Our results support the normalization reweighting model, and indicate that for prolonged stimulation, increases in suppression occur on the order of 2-5 seconds after stimulus onset.

# Introduction

Suppressive interactions between neurons are ubiquitous in the nervous system, and normalization (or gain control) processes are considered a canonical neuronal computation [@Carandini2011]. Yet for decades the strength of suppression was treated as fixed, largely due to the observation that adapting to one stimulus does not decrease its suppressive potency [@Foley1997; @Freeman2002]. This orthodoxy was recently challenged by a series of innovative studies showing that normalization can be 'reweighted' by recent history [@Westrick2016; @Aschner2018; @Yiltiz2020]. Specifically, when pairs of stimuli are repeatedly presented together, their neural representations come to suppress each other more strongly. This suggests that, far from being fixed, normalization is a dynamic process that is continuously updated by the sensory environment. Here, our objectives were to determine if the timecourse of these changes can be measured non-invasively from the human brain, assess if they occur similarly in distinct suppressive pathways, and determine whether they differ across the population as a function of autistic traits.

Plastic changes within the visual system occur over multiple timescales [see @Webster2015 for a recent review]. In the retina, adaptation to complete darkness takes around 30 minutes [@Lamb2006], and has established physiological substrates (i.e. the regeneration rate of chemicals in different photoreceptor classes). Cortical forms of adaptation to cues such as stimulus contrast [@Blakemore1969], orientation [@Gibson1937] and motion [@Mather2008] can be observed within a few seconds, but also build up over durations on the order of several minutes [@Greenlee1991]. A recent form of binocular plasticity [@Lunghi2011], in which one eye is patched and subsequently contributes more to binocular vision, requires more than an hour. Other types of adaptation have been identified with changes occurring over longer time periods, such as over several hours [@Kwon2009] or days [@Haak2014]. Finally adaptation to specific combinations of orientation and colour [the @McCollough1965 effect] can persist for several weeks [@Jones1975], even with a brief induction period. Previous work on normalization reweighting has involved adapting sequences of around 40 -- 60s [@Aschner2018; @Yiltiz2020], though it is possible that reweighting might occur faster than this, consistent with other types of contrast adaptation.

Normalization itself is not a single process. Multiple suppressive pathways have been identified in the visual system, including between stimuli differing in orientation [@Heeger1992; @Foley1994], eye-of-origin [@Legge1979; @Sengpiel1994] and spatial position [@Petrov2005; @Cannon1991]. At present there is evidence of normalization reweighting between stimuli with orthogonal orientations [@Aschner2018], and adjacent spatial positions [@Yiltiz2020]. We anticipated that interocular suppression should also be subject to reweighting, but that there might be differences in the dynamics across suppressive pathways. This is plausible, given that suppression within and between the eyes has different spatiotemporal tuning [@Meese2009], and dichoptic masking can be reduced by adapting to the mask [@Sengpiel2005; @Li2005; @Baker2007], unlike within-eye masking. Dynamic fluctuations in interocular suppression are a key feature of binocular rivalry [@Wilson2003; @Alais2010], for which autism-related differences have also been reported [@Robertson2013]. By comparing monocular and dichoptic suppression, we are also able to isolate any contribution of early pre-cortical factors. This is because interocular suppression impacts in primary visual cortex, and therefore bypasses earlier retinal and subcortical stages of processing that may contribute to monocular suppression [@Li2005].

Atypical sensory experience is widely reported by individuals on the autism spectrum [@MacLennan2022; @Simmons2009], but the causal mechanisms remain unclear. Typical issues include hypersensitivity to intense stimuli such as loud sounds, bright lights and strong odours or flavours. Yet fundamental measures of sensitivity such as visual acuity [@Tavassoli2011], contrast sensitivity [@Koh2010], and audiometric performance [@Rosenhall1999] are not consistently different from neurotypical controls. Theoretical accounts of sensory differences in autism have long proposed that the balance of inhibition and excitation may be disrupted [@Rubenstein2003; @Rosenberg2015], and there are isolated results that appear consistent with this. For example neural measures of surround suppression are weaker in autism [@Schallmo2020], binocular rivalry is slower [@Robertson2013] and orientation discrimination performance is better [@Dickinson2014]. Conversely, other studies have failed to find group differences using paradigms that should be equally dependent on inhibition, such as orientation repulsion [@VandeCruys2018], repetition suppression [@Utzerath2018] and psychophysical measures of surround suppression [@Sandhu2020]. The evidence for atypical inhibition in autism is therefore currently inconclusive.

Our recent work has identified a potential autism-related difference in gain control using steady-state EEG methods. @Vilidaite2018 measured contrast response functions for flickering stimuli in a large group of neurotypical adults, who were grouped according to their autism quotient [AQ, see @Baron-Cohen2001] score. The responses were comparable between high and low AQ groups at the flicker frequency of the stimulus. However at the second harmonic frequency (twice the flicker frequency), the high AQ group showed weaker responses than the low AQ group. This effect was replicated in an independent sample of 12 adults with an autism diagnosis (compared with neurotypical controls). Because second harmonic responses are caused by nonlinear interactions in the visual system (they are absent in a linear system), and divisive suppression is a nonlinearity, this potentially implicates differences in suppression in autism. Furthermore, there appears to be a developmental trajectory, as autistic children tested as part of the same study [@Vilidaite2018] showed weaker responses at both the first and second harmonic frequencies.

In this paper we perform a time-course analysis of a previously published EEG data set, and report two novel pre-registered experiments using EEG and MEG. Our data show that suppression increases substantially during the first 2-5 seconds following stimulus onset, for both monocular and dichoptic masks. Source localisation of MEG data indicate that the reweighting is present as early as primary visual cortex (V1). We also hypothesised that normalization reweighting might differ as a function of autistic traits. The relative novelty of the reweighting framework could explain why any differences have not previously been detected, and why the literature on inhibition in autism is relatively inconclusive. However we did not find convincing support for this hypothesis.

# Results

```{r include=FALSE, results='hide'}

# single participant analysis of data from Vilidaite et al. (2018)

samplerate <- 1000
targetF <- 7
maskF <- 5
tindex <- (10*targetF) + 1
mindex <- (10*maskF) + 1
duration <- 14

    binwidth <- 1000
    findex <- 1 + targetF*(binwidth/1000)
    findex[2] <- 1 + maskF*(binwidth/1000)
    findex[3] <- 1 + 2*targetF*(binwidth/1000)
    findex[4] <- 1 + 2*maskF*(binwidth/1000)
    
condlist <- c(6,8,13)

if (processdata>2){
  
datadir <- 'temp/pilotraw/'

legaltriggers <- hdata$Trigger[!is.na(hdata$Trigger)]
subjcounter <- 0

for (s in 1:101) {
  if (s != 75) {
    subjcounter <- subjcounter + 1  
  if (!file.exists(paste0('temp/VilidaiteProcessed/V',subjcounter,'processed.RData'))){
  print(s)
    
    if (s < 10){subname <- paste0('S0', s)}
    if (s > 9){subname <- paste0('S', s)}
    
    tarname <- paste0(subname,'.tar')
    
    if (!file.exists(paste0(datadir,tarname))){
      fid <- which(pilotfiles$name==tarname)
      osf_download(pilotfiles[fid,],datadir,progress=TRUE)
    }
    untar(paste0(datadir,tarname),exdir=paste0(datadir,subname))
    file.remove(paste0(datadir,tarname))  # delete after unpacking
    
    condcounter <- (1:20) * 0
    allsamples <- array(0, dim = c(10,20,64,duration*samplerate))
    d <- dir(path = paste0(datadir,subname), pattern='*.csv.gz',full.names=TRUE)
    
    for (block in 1:length(d)) {
      EEGdata <- read.csv(d[block], header = TRUE)
      
      electrodes <- colnames(EEGdata)
      targetchannels <- match(targetelectrodes, electrodes) - 2
      
      # epoch the data, Fourier transform and store
      triggertimes <- (1:40) * 0
      counter <- 0
       # ignore triggers starting in the first 1000ms that generate an error
      for (n in 1500:nrow(EEGdata)) {   
        if (EEGdata$Trigger[n] %in% legaltriggers) {
          counter <- counter + 1
          triggertimes[counter] <- n
      }
      }
      
      for (tr in 1:counter) {
        cond <- EEGdata$Trigger[triggertimes[tr]] / 10
        condcounter[cond] <- condcounter[cond] + 1
        for (ch in 1:64){
        temp <- as.matrix(EEGdata[(triggertimes[tr]:(triggertimes[tr] + samplerate * duration - 1))-1499, ch + 2])
        temp <- temp - mean(temp[501:1500])  # subtract mean of 1 second pre-trial baseline average
        allsamples[condcounter[cond],cond,ch,1:(1000*duration)] <- as.vector(rowMeans(temp))
        }
      }
    }
allsamples[which(is.na(allsamples))] <- 0     # remove any NaN values
meanwaveforms <- array(0,dim=c(14,64,14000))
trialsincluded <- matrix(0,nrow=14,ncol=64)
    for (cond in 1:14){
      for (ch in 1:64){
        temp <- allsamples[1:condcounter[cond],cond,ch,]
        allspec <- matrix(0,nrow=condcounter[cond],ncol=10000)
        for (trial in 1:condcounter[cond]){
          allspec[trial,] <- fft(temp[trial,2501:12500])/10000
        }
        targetresps <- allspec[,tindex]
        maskresps <- allspec[,mindex]
      if (sum(abs(targetresps))>0){  
      tempxy <- data.frame(Re(targetresps),Im(targetresps))
      D <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
      i1 <- (D<3)
      tempxy <- data.frame(Re(maskresps),Im(maskresps))
      D <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
      i2 <- (D<3)
      i <- which((i1*i2)>0)
        meanwaveforms[cond,ch,] <- colMeans(temp[i,])
        trialsincluded[cond,ch] <- length(i)
      }
      }
    }
    
     save(file = paste0('temp/VilidaiteProcessed/V',subjcounter,'processed.RData'), list = c('meanwaveforms','electrodes','trialsincluded'))
     
     # optionally delete the files after use
    # for (block in 1:length(d)){file.remove(d[block])}

  }
}
}
}

```

```{r include=FALSE, results='hide'}

# group level analysis of data from Vilidaite et al. (2018)

if (processdata>1){

d <- dir(path = 'temp/VilidaiteProcessed', pattern = '*.RData', full.names=TRUE)

# download any missing data files from osf
if (length(d)<100){
  pilotrepo <- pmatch('Processed pilot data',as.character(unlist(componentlist[,1])))
  pilotfiles <- osf_ls_files(componentlist[pilotrepo,2],n_max=300)
  for (s in 1:length(pilotfiles)){
    if (!file.exists(paste0('temp/VilidaiteProcessed/',pilotfiles[s,1]))){
      osf_download(pilotfiles[s,],'temp/VilidaiteProcessed/',progress=TRUE)
    }
  }
}

d <- dir(path = 'temp/VilidaiteProcessed', pattern = '*.RData', full.names=TRUE)

EEGtimecourse <- array(0,dim=c(length(d),length(findex),3,13000))
EEGspectra <- array(0,dim=c(length(d),3,20*10))
EEGscalpresps <- array(0,dim=c(length(d),4,14,64))
EEGallconds <- array(0,dim=c(length(d),4,14))
alltrialcounts <- array(0,dim=c(length(d),14,64))

for (s in 1:length(d)){
  load(d[s])
  targetchannels <- match(targetelectrodes, electrodes) - 2
  alltrialcounts[s,,] <- trialsincluded
  
  for (cond in 1:14){
    temp <- colMeans(meanwaveforms[cond,targetchannels,],na.rm=TRUE)
        nainds <- which(is.na(temp))   # find occasional NaN values in the waveform
    temp[nainds] <- 0   # replace with zeros
    spec <- fft(temp[2501:12500])/10000
    EEGallconds[s,1,cond] <- spec[1+(10*targetF)]
    EEGallconds[s,2,cond] <- spec[1+(10*maskF)]
    EEGallconds[s,3,cond] <- spec[1+(2*10*targetF)]
    EEGallconds[s,4,cond] <- spec[1+(2*10*maskF)]
  }
  for (cond in 1:3){
    temp <- colMeans(meanwaveforms[condlist[cond],targetchannels,],na.rm=TRUE)
    nainds <- which(is.na(temp))   # find occasional NaN values in the waveform
    temp[nainds] <- 0   # replace with zeros

    spec <- fft(temp[2501:12500])/10000
    EEGspectra[s,cond,] <- spec[1:(20*10)]
    
for (t in 1:(14000-binwidth)){
  spec <- fft(temp[t:(t+binwidth-1)])/binwidth
  for (f in 1:length(findex)){
  EEGtimecourse[s,f,cond,t] <- spec[findex[f]]
  }
}
  } 
  
for (cond in 1:14){
  for (ch in 1:64){
     temp <- meanwaveforms[cond,ch,]
    nainds <- which(is.na(temp))   # find occasional NaN values in the waveform
    temp[nainds] <- 0   # replace with zeros
   spec <- fft(temp[2501:12500])/10000
   EEGscalpresps[s,1,cond,ch] <- spec[(targetF*10)+1]
   EEGscalpresps[s,2,cond,ch] <- spec[(maskF*10)+1]
   EEGscalpresps[s,3,cond,ch] <- spec[(2*targetF*10)+1]
   EEGscalpresps[s,4,cond,ch] <- spec[(2*maskF*10)+1]
  }
}  
  
  
  
}

save(file='temp/Pilotsummary.RData',list=c('EEGtimecourse','electrodes','EEGscalpresps','EEGspectra','EEGallconds','alltrialcounts'))
}

```

```{r include=FALSE, results='hide'}

# plot data from Vilidaite et al. (2018)

if (processdata>0){

      if (!file.exists('temp/Pilotsummary.RData')){
      hid <- pmatch('Pilotsummary.RData',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
      }  
load('temp/Pilotsummary.RData')

nsubjs <- dim(EEGtimecourse)[1]
EEGmeantimes <- array(0,dim=c(length(findex),3,13000))
EEGSEtimes <- array(0,dim=c(length(findex)+1,3,13000))
EEGmaskindices <- array(0,dim=c(length(findex)+1,13000))
EEGmaskSE <- array(0,dim=c(length(findex)+1,13000))
EEGmeanscalp <- abs(apply(abs(EEGscalpresps),2:4,mean))
EEGmeanspec <- abs(apply(abs(EEGspectra),2:3,mean))
EEGmeanconds <- apply(abs(EEGallconds),2:3,mean)
EEGcondsSE <- apply(abs(EEGallconds),2:3,sd)/sqrt(nsubjs)

for (f in 1:length(findex)){
for (cond in 1:3){
EEGmeantimes[f,cond,] <- apply(abs(EEGtimecourse[,f,cond,]),2,mean,na.rm=TRUE)
EEGSEtimes[f,cond,] <- apply(abs(EEGtimecourse[,f,cond,]),2,sd,na.rm=TRUE)/sqrt(nsubjs)
}}


EEGmaskindices[1,] <- colMeans(20*log10(abs(EEGtimecourse[,1,1,])/abs(EEGtimecourse[,1,3,])))
EEGmaskindices[2,] <- colMeans(20*log10(abs(EEGtimecourse[,2,2,])/abs(EEGtimecourse[,2,3,])))
EEGmaskindices[3,] <- colMeans(20*log10(abs(EEGtimecourse[,3,1,])/abs(EEGtimecourse[,3,3,])))
EEGmaskindices[4,] <- colMeans(20*log10(abs(EEGtimecourse[,4,2,])/abs(EEGtimecourse[,4,3,])))


meanindices <- (20*log10(abs(EEGtimecourse[,1,1,])/abs(EEGtimecourse[,1,3,])) + 20*log10(abs(EEGtimecourse[,2,2,])/abs(EEGtimecourse[,2,3,])) + 20*log10(abs(EEGtimecourse[,3,1,])/abs(EEGtimecourse[,3,3,])) + 20*log10(abs(EEGtimecourse[,4,2,])/abs(EEGtimecourse[,4,3,])))/4
EEGmaskindices[5,] <- colMeans(meanindices)

earlydata <- meanindices*0
latedata <- meanindices*0
earlydata[,1:(dim(meanindices)[2]-(timeoffset/2))] <- meanindices[,1:(dim(meanindices)[2]-(timeoffset/2))]
earlydata[,1:(timeoffset/2)] <- 0
latedata[,(1+(timeoffset/2)):(dim(meanindices)[2])] <- meanindices[,1:(dim(meanindices)[2]-(timeoffset/2))]
latedata[1:dim(meanindices)[1],(dim(meanindices)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustout <- clustercorrect(earlydata,latedata,testtype=4,paired=TRUE)}

EEGmaskSE[1,] <- apply(20*log10(abs(EEGtimecourse[,1,1,])/abs(EEGtimecourse[,1,3,])),2,sd)/sqrt(nsubjs)
EEGmaskSE[2,] <- apply(20*log10(abs(EEGtimecourse[,2,2,])/abs(EEGtimecourse[,2,3,])),2,sd)/sqrt(nsubjs)
EEGmaskSE[3,] <- apply(20*log10(abs(EEGtimecourse[,3,1,])/abs(EEGtimecourse[,3,3,])),2,sd)/sqrt(nsubjs)
EEGmaskSE[4,] <- apply(20*log10(abs(EEGtimecourse[,4,2,])/abs(EEGtimecourse[,4,3,])),2,sd)/sqrt(nsubjs)
EEGmaskSE[5,] <- apply(meanindices,2,sd)/sqrt(nsubjs)


times <- (-999:12000)/1000

postscript("timecourse1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plotlims <- c(-1,12,0,1)
ticklocsx <- c(-1,seq(0,12,2))    # locations of tick marks on y axis
ticklocsy <- seq(0,1,0.2)    # locations of tick marks on y axis
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = seq(0,12,2), side = 1, at=seq(0,12,2))
mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,11,11,0),c(-0.035,-0.035,0.04,0.04),border=NA,col=rgb(0.5,0.5,0.5))

if (plotsmoothed==0){
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[1,1,]+EEGSEtimes[1,1,],EEGmeantimes[1,1,13000:1]-EEGSEtimes[1,1,13000:1]),col=colpal[1],border=NA)
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[1,2,]+EEGSEtimes[1,2,],EEGmeantimes[1,2,13000:1]-EEGSEtimes[1,2,13000:1]),col='grey',border=NA)
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[1,3,]+EEGSEtimes[1,3,],EEGmeantimes[1,3,13000:1]-EEGSEtimes[1,3,13000:1]),col=colpal[2],border=NA)

lines(times,EEGmeantimes[1,1,],col=colpal[1])
lines(times,EEGmeantimes[1,2,],col='grey')
lines(times,EEGmeantimes[1,3,],col=colpal[2])
}
if (plotsmoothed==1){
  
spl5aU <- smooth.spline(times,EEGmeantimes[1,1,]+EEGSEtimes[1,1,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[1,1,]-EEGSEtimes[1,1,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[1],border=NA)

spl5aU <- smooth.spline(times,EEGmeantimes[1,2,]+EEGSEtimes[1,2,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[1,2,]-EEGSEtimes[1,2,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col='grey',border=NA)

spl5aU <- smooth.spline(times,EEGmeantimes[1,3,]+EEGSEtimes[1,3,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[1,3,]-EEGSEtimes[1,3,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[2],border=NA)

spl5a <- smooth.spline(times,EEGmeantimes[1,1,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[1],lwd=2)
spl5a <- smooth.spline(times,EEGmeantimes[1,2,],df=20)
lines(spl5a$x,spl5a$y,col='grey',lwd=2)
spl5a <- smooth.spline(times,EEGmeantimes[1,3,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[2],lwd=2)
}
text(10,0.95,'7Hz',cex=2)

dev.off()

postscript("timecourse2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = seq(0,12,2), side = 1, at=seq(0,12,2))
mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,11,11,0),c(-0.035,-0.035,0.04,0.04),border=NA,col=rgb(0.5,0.5,0.5))

if (plotsmoothed==0){
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[2,2,]+EEGSEtimes[2,2,],EEGmeantimes[2,2,13000:1]-EEGSEtimes[2,2,13000:1]),col=colpal[1],border=NA)
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[2,1,]+EEGSEtimes[2,1,],EEGmeantimes[2,1,13000:1]-EEGSEtimes[2,1,13000:1]),col='grey',border=NA)
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[2,3,]+EEGSEtimes[2,3,],EEGmeantimes[2,3,13000:1]-EEGSEtimes[2,3,13000:1]),col=colpal[2],border=NA)

lines(times,EEGmeantimes[2,2,],col=colpal[1])
lines(times,EEGmeantimes[2,1,],col='grey')
lines(times,EEGmeantimes[2,3,],col=colpal[2])
}
if (plotsmoothed==1){
  
spl5aU <- smooth.spline(times,EEGmeantimes[2,2,]+EEGSEtimes[2,2,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[2,2,]-EEGSEtimes[2,2,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[1],border=NA)

spl5aU <- smooth.spline(times,EEGmeantimes[2,1,]+EEGSEtimes[2,1,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[2,1,]-EEGSEtimes[2,1,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col='grey',border=NA)

spl5aU <- smooth.spline(times,EEGmeantimes[2,3,]+EEGSEtimes[2,3,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[2,3,]-EEGSEtimes[2,3,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[2],border=NA)

spl5a <- smooth.spline(times,EEGmeantimes[2,2,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[1],lwd=2)
spl5a <- smooth.spline(times,EEGmeantimes[2,1,],df=20)
lines(spl5a$x,spl5a$y,col='grey',lwd=2)
spl5a <- smooth.spline(times,EEGmeantimes[2,3,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[2],lwd=2)
}
text(10,0.95,'5Hz',cex=2)

dev.off()

postscript("timecourse3.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = seq(0,12,2), side = 1, at=seq(0,12,2))
mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,11,11,0),c(-0.035,-0.035,0.04,0.04),border=NA,col=rgb(0.5,0.5,0.5))

if (plotsmoothed==0){
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[3,1,]+EEGSEtimes[3,1,],EEGmeantimes[3,1,13000:1]-EEGSEtimes[3,1,13000:1]),col=colpal[1],border=NA)
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[3,2,]+EEGSEtimes[3,2,],EEGmeantimes[3,2,13000:1]-EEGSEtimes[3,2,13000:1]),col='grey',border=NA)
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[3,3,]+EEGSEtimes[3,3,],EEGmeantimes[3,3,13000:1]-EEGSEtimes[3,3,13000:1]),col=colpal[2],border=NA)

lines(times,EEGmeantimes[3,1,],col=colpal[1])
lines(times,EEGmeantimes[3,2,],col='grey')
lines(times,EEGmeantimes[3,3,],col=colpal[2])
}
if (plotsmoothed==1){
  
spl5aU <- smooth.spline(times,EEGmeantimes[3,1,]+EEGSEtimes[3,1,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[3,1,]-EEGSEtimes[3,1,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[1],border=NA)

spl5aU <- smooth.spline(times,EEGmeantimes[3,2,]+EEGSEtimes[3,2,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[3,2,]-EEGSEtimes[3,2,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col='grey',border=NA)

spl5aU <- smooth.spline(times,EEGmeantimes[3,3,]+EEGSEtimes[3,3,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[3,3,]-EEGSEtimes[3,3,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[2],border=NA)

spl5a <- smooth.spline(times,EEGmeantimes[3,1,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[1],lwd=2)
spl5a <- smooth.spline(times,EEGmeantimes[3,2,],df=20)
lines(spl5a$x,spl5a$y,col='grey',lwd=2)
spl5a <- smooth.spline(times,EEGmeantimes[3,3,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[2],lwd=2)
}
text(10,0.95,'14Hz',cex=2)

dev.off()

postscript("timecourse4.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = seq(0,12,2), side = 1, at=seq(0,12,2))
mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,11,11,0),c(-0.035,-0.035,0.04,0.04),border=NA,col=rgb(0.5,0.5,0.5))

if (plotsmoothed==0){
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[4,2,]+EEGSEtimes[4,2,],EEGmeantimes[4,2,13000:1]-EEGSEtimes[4,2,13000:1]),col=colpal[1],border=NA)
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[4,1,]+EEGSEtimes[4,1,],EEGmeantimes[4,1,13000:1]-EEGSEtimes[4,1,13000:1]),col='grey',border=NA)
polygon(times[c(1:13000,13000:1)],c(EEGmeantimes[4,3,]+EEGSEtimes[4,3,],EEGmeantimes[4,3,13000:1]-EEGSEtimes[4,3,13000:1]),col=colpal[2],border=NA)

lines(times,EEGmeantimes[4,2,],col=colpal[1])
lines(times,EEGmeantimes[4,1,],col='grey')
lines(times,EEGmeantimes[4,3,],col=colpal[2])
}
if (plotsmoothed==1){
  
spl5aU <- smooth.spline(times,EEGmeantimes[4,2,]+EEGSEtimes[4,2,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[4,2,]-EEGSEtimes[4,2,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[1],border=NA)

spl5aU <- smooth.spline(times,EEGmeantimes[4,1,]+EEGSEtimes[4,1,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[4,1,]-EEGSEtimes[4,1,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col='grey',border=NA)

spl5aU <- smooth.spline(times,EEGmeantimes[4,3,]+EEGSEtimes[4,3,],df=20)
spl5aL <- smooth.spline(times,EEGmeantimes[4,3,]-EEGSEtimes[4,3,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[2],border=NA)

spl5a <- smooth.spline(times,EEGmeantimes[4,2,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[1],lwd=2)
spl5a <- smooth.spline(times,EEGmeantimes[4,1,],df=20)
lines(spl5a$x,spl5a$y,col='grey',lwd=2)
spl5a <- smooth.spline(times,EEGmeantimes[4,3,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[2],lwd=2)
}
text(10,0.95,'10Hz',cex=2)

dev.off()


postscript("suppression.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plotlims <- c(-1,12,-3,6)
ticklocsx <- c(-1,seq(0,12,2))    # locations of tick marks on y axis
ticklocsy <- seq(-3,6,3)    # locations of tick marks on y axis
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = seq(0,12,2), side = 1, at=seq(0,12,2))
mtext(text = c(expression(sqrt(2)/2),'1',expression(sqrt(2)),'2'), side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Suppression ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,11,11,0),c(-3.4,-3.4,-2.6,-2.6),border=NA,col=rgb(0.5,0.5,0.5))

lines(c(-1,12),c(0,0),lty=2)

if (plotsmoothed==0){
  
# for (f in 1:4){
# polygon(times[c(1:13000,13000:1)],c(EEGmaskindices[f,]+EEGmaskSE[f,],EEGmaskindices[f,13000:1]-EEGmaskSE[f,13000:1]),col=colpal[f+1],border=NA)
# }
  polygon(times[c(1:13000,13000:1)],c(EEGmaskindices[5,]+EEGmaskSE[5,],EEGmaskindices[5,13000:1]-EEGmaskSE[5,13000:1]),col=colpal[1],border=NA)

for (f in 1:4){lines(times,EEGmaskindices[f,],col=colpal[f+1])}
lines(times,EEGmaskindices[5,],col=colpal[1],lwd=4)
}

if (plotsmoothed==1){
# for (f in 1:4){  
# spl5aU <- smooth.spline(times,EEGmaskindices[f,]+EEGmaskSE[f,],df=20)
# spl5aL <- smooth.spline(times,EEGmaskindices[f,]-EEGmaskSE[f,],df=20)
# polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[f+1],border=NA)
# }
  spl5aU <- smooth.spline(times,EEGmaskindices[5,]+EEGmaskSE[5,],df=20)
spl5aL <- smooth.spline(times,EEGmaskindices[5,]-EEGmaskSE[5,],df=20)
polygon(times[c(1:13000,13000:1)],c(spl5aU$y,spl5aL$y[13000:1]),col=colpal[1],border=NA)

for (f in 1:4){
spl5a <- smooth.spline(times,EEGmaskindices[f,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[f+1],lwd=2)
}
spl5a <- smooth.spline(times,EEGmaskindices[5,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[1],lwd=6)
}
legend(1,0,c('7Hz','5Hz'),lwd=4,col=colpal[c(2,3)],bty='n')
legend(5,0,c('14Hz','10Hz'),lwd=4,col=colpal[c(4,5)],bty='n')
legend(3,-1.4,c('Mean'),lwd=6,col=colpal[1],bty='n')

  if (nbootstraps>0){
    for (n in 1:clustout$nclusters){
      temp <- unlist(clustout$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]]-((timeoffset/2)/1000),c(5.5, 5.5),lwd=3)
    }
  }

dev.off()


freqlist <- seq(0,19.9,1/10)

postscript("spectrum.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 10)

plotlims <- c(0,20,0,3)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(0,20,5)    # locations of tick marks on x axis
ticklocsy <- c(0,0.4,0.8,1,2,3)    # locations of tick marks on y axis
ticklabelsx <- seq(0,20,5)        # set labels for x ticks
ticklabelsy <- c(0,0.2,0.4,'','','')    # set labels for y ticks
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(0,20),c(0,0),lty=3)
lines(c(0,20),c(1,1),lty=3)
lines(c(0,20),c(2,2),lty=3)

polygon(c(freqlist[11],freqlist[11:200],19.9),c(0,2*EEGmeanspec[1,11:200],0)+2,border=NA,col=colpal[1])
polygon(c(freqlist[11],freqlist[11:200],19.9),c(0,2*EEGmeanspec[2,11:200],0)+1,border=NA,col=colpal[2])
polygon(c(freqlist[11],freqlist[11:200],19.9),c(0,2*EEGmeanspec[3,11:200],0),border=NA,col=colpal[3])

lines(freqlist[11:200],2*EEGmeanspec[1,11:200]+2,lwd=2,col='black')
lines(freqlist[11:200],2*EEGmeanspec[2,11:200]+1,lwd=2,col='black')
lines(freqlist[11:200],2*EEGmeanspec[3,11:200],lwd=2,col='black')

text(20,2.5,'7Hz target',pos=2,cex=1.5)
text(20,1.5,'5Hz mask',pos=2,cex=1.5)
text(20,0.5,'Plaid',pos=2,cex=1.5)

dev.off()



postscript("CRFs.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 9)

contrastsdB <- seq(0,36,6)

plotlims <- c(0,78,0,0.8)
ticklocsx <- seq(0,36,6)    # locations of tick marks on y axis
ticklocsy <- seq(0,0.8,0.2)    # locations of tick marks on y axis
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = c(0,2,4,8,16,32,64), side = 1, at=ticklocsx)
mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
axis(1, at=ticklocsx+42, tck=0.01, lab=F, lwd=2)
mtext(text = c(0,2,4,8,16,32,64), side = 1, at=ticklocsx+42)
title(xlab="Target contrast (%)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

arrows(contrastsdB,EEGmeanconds[1,1:7],contrastsdB,EEGmeanconds[1,1:7]+EEGcondsSE[1,1:7],lwd=2,angle=90,length=0.015,col=colpal[1])
arrows(contrastsdB,EEGmeanconds[1,1:7],contrastsdB,EEGmeanconds[1,1:7]-EEGcondsSE[1,1:7],lwd=2,angle=90,length=0.015,col=colpal[1])

arrows(contrastsdB,EEGmeanconds[1,8:14],contrastsdB,EEGmeanconds[1,8:14]+EEGcondsSE[1,8:14],lwd=2,angle=90,length=0.015,col=colpal[2])
arrows(contrastsdB,EEGmeanconds[1,8:14],contrastsdB,EEGmeanconds[1,8:14]-EEGcondsSE[1,8:14],lwd=2,angle=90,length=0.015,col=colpal[2])

lines(contrastsdB,EEGmeanconds[1,1:7],lwd=2,col=colpal[1])
lines(contrastsdB,EEGmeanconds[1,8:14],lwd=2,col=colpal[2])

points(contrastsdB,EEGmeanconds[1,1:7],pch=16,cex=1.5,col=colpal[1])
points(contrastsdB,EEGmeanconds[1,8:14],pch=15,cex=1.5,col=colpal[2])

points(contrastsdB[6],EEGmeanconds[1,6],pch=16,cex=2.5,col=colpal[1])
points(contrastsdB[6],EEGmeanconds[1,13],pch=15,cex=2.5,col=colpal[2])


contrastsdB <- contrastsdB+42

arrows(contrastsdB,EEGmeanconds[2,1:7],contrastsdB,EEGmeanconds[2,1:7]+EEGcondsSE[2,1:7],lwd=2,angle=90,length=0.015,col=colpal[1])
arrows(contrastsdB,EEGmeanconds[2,1:7],contrastsdB,EEGmeanconds[2,1:7]-EEGcondsSE[2,1:7],lwd=2,angle=90,length=0.015,col=colpal[1])

arrows(contrastsdB,EEGmeanconds[2,8:14],contrastsdB,EEGmeanconds[2,8:14]+EEGcondsSE[2,8:14],lwd=2,angle=90,length=0.015,col=colpal[2])
arrows(contrastsdB,EEGmeanconds[2,8:14],contrastsdB,EEGmeanconds[2,8:14]-EEGcondsSE[2,8:14],lwd=2,angle=90,length=0.015,col=colpal[2])

lines(contrastsdB,EEGmeanconds[2,1:7],lwd=2,col=colpal[1])
lines(contrastsdB,EEGmeanconds[2,8:14],lwd=2,col=colpal[2])

points(contrastsdB,EEGmeanconds[2,1:7],pch=16,cex=1.5,col=colpal[1])
points(contrastsdB,EEGmeanconds[2,8:14],pch=15,cex=1.5,col=colpal[2])

points(contrastsdB[1],EEGmeanconds[2,8],pch=15,cex=2.5,col=colpal[2])
points(contrastsdB[6],EEGmeanconds[2,13],pch=15,cex=2.5,col=colpal[2])

text(18,0.78,'7Hz response',cex=2,adj=0.5)
text(42+18,0.78,'5Hz response',cex=2,adj=0.5)

legend(65,0.7,c('Target','Target+mask'),pch=16:15,col=colpal[1:2],bty='n')

dev.off()


xpos <- 1:64
ypos <- 1:64
montageE <- toupper(as.character(hdata$Electrode))
for (ch in 1:64){
  i <- match(toupper(electrodes[ch+2]),montageE)
  xpos[ch] <- hdata$X_position[i]
  ypos[ch] <- hdata$Y_position[i]
}


for (f in 1:2){
rmax <- 0.55   #specify a maximum boundary for the grid
gridRes <- 100 #specify the interpolation grid resolution

datatoplot <- abs(EEGmeanscalp[f,condlist[f],])
datatoplot[which(is.na(datatoplot))] <- 0
datatoplot[which(datatoplot<0)] <- 0
datatoplot[which(datatoplot>30)] <- 0

testDat<- data.frame(x = xpos,
                     y = -ypos,
                     z = datatoplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0

ramp2 <- colorRamp(c("white",colpal[2]))  
colmatrix2 <- rgb(ramp2(seq(0, 1, length = 101)), max = 255)


tiff(paste0('headplot',f,'.tif'), height = 600, width = 600, units="px", bg="white")
    
plotlims <- c(-rmax,rmax,-rmax,rmax)  
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4]) 
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,0.7),add=TRUE,useRaster=FALSE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match('OZ',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('POZ',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('O1',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('O2',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

dev.off()
}


  e1 <- readTIFF('headplot1.tif')
  e2 <- readTIFF('headplot2.tif')

  PostScriptTrace(paste('CRFs.ps',sep=''))
  e3 <- readPicture('CRFs.ps.xml')
  PostScriptTrace(paste('suppression.ps',sep=''))
  e4 <- readPicture('suppression.ps.xml')
  for (n in 1:length(e4@paths)){
    temp <- class(e4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e4@paths[n]$path@rgb))<765){e4@paths[n]$path@rgb <- addalpha(e4@paths[n]$path@rgb,alpha=0.2)}}}
  
  PostScriptTrace(paste('spectrum.ps',sep=''))
  e5 <- readPicture('spectrum.ps.xml')
  for (n in 1:length(e5@paths)){
    temp <- class(e5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e5@paths[n]$path@rgb))<765){e5@paths[n]$path@rgb <- addalpha(e5@paths[n]$path@rgb,alpha=0.2)}}}

   PostScriptTrace(paste('timecourse1.ps',sep=''))
  e6 <- readPicture('timecourse1.ps.xml')
  for (n in 1:length(e6@paths)){
    temp <- class(e6@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e6@paths[n]$path@rgb))<765){e6@paths[n]$path@rgb <- addalpha(e6@paths[n]$path@rgb,alpha=0.2)}}}
 
   PostScriptTrace(paste('timecourse2.ps',sep=''))
  e7 <- readPicture('timecourse2.ps.xml')
  for (n in 1:length(e7@paths)){
    temp <- class(e7@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e7@paths[n]$path@rgb))<765){e7@paths[n]$path@rgb <- addalpha(e7@paths[n]$path@rgb,alpha=0.2)}}}

     PostScriptTrace(paste('timecourse3.ps',sep=''))
  e8 <- readPicture('timecourse3.ps.xml')
  for (n in 1:length(e8@paths)){
    temp <- class(e8@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e8@paths[n]$path@rgb))<765){e8@paths[n]$path@rgb <- addalpha(e8@paths[n]$path@rgb,alpha=0.2)}}}

     PostScriptTrace(paste('timecourse4.ps',sep=''))
  e9 <- readPicture('timecourse4.ps.xml')
  for (n in 1:length(e9@paths)){
    temp <- class(e9@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e9@paths[n]$path@rgb))<765){e9@paths[n]$path@rgb <- addalpha(e9@paths[n]$path@rgb,alpha=0.2)}}}
  
  
  
  pdf('Figures/VilidaiteData.pdf', bg="transparent", height = 6, width = 16)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1)) 

  aspratio <- 6/16  # this is the aspect ratio of the output pdf
  imwidth <- 0.25
  xstart <- 0.02
  ystart <- 0.58
  rasterImage(e1,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)
  xstart <- 0.22
  ystart <- 0.58
  rasterImage(e2,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)

  grid.picture(e3,x=0.225,y=0.7,width=0.4,height=1)
  grid.picture(e5,x=0.225,y=0.25,width=0.4,height=1)

  grid.picture(e6,x=0.5,y=0.85,width=0.1,height=1)
  grid.picture(e7,x=0.5,y=0.625,width=0.1,height=1)
  grid.picture(e8,x=0.5,y=0.375,width=0.1,height=1)
  grid.picture(e9,x=0.5,y=0.15,width=0.1,height=1)
  grid.picture(e4,x=0.77,y=0.5,width=0.45,height=1)
  
  text(-0.02,0.98,'(a)',pos=4,cex=2)
  text(-0.02,0.45,'(b)',pos=4,cex=2)
  text(0.41,0.98,'(c)',pos=4,cex=2)
  text(0.57,0.98,'(d)',pos=4,cex=2)
  

  dev.off()
  
  file.remove(c('headplot1.tif','headplot2.tif','spectrum.ps','timecourse1.ps','timecourse2.ps','timecourse3.ps','timecourse4.ps','suppression.ps','CRFs.ps'))
  file.remove(c('spectrum.ps.xml','timecourse1.ps.xml','timecourse2.ps.xml','timecourse3.ps.xml','timecourse4.ps.xml','suppression.ps.xml','CRFs.ps.xml'))


}

```

```{r include=FALSE, results='hide'}

# do statistics for Vilidiate et al. data

 if (!file.exists('temp/Pilotsummary.RData')){
      hid <- pmatch('Pilotsummary.RData',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
}
load('temp/Pilotsummary.RData')

Pilotpercentexcluded <- 100 - (100*mean(alltrialcounts[,condlist,28:31])/8)
targetcond <- NULL
maskcond <- NULL
subj <- NULL
targetamp <- NULL
maskamp <- NULL
i <- 0
for (s in 1:100){
  for (cond in 1:14){
    i <- i + 1
    subj[i] <- s
    targetcond[i] <- ((cond-1) %% 7) + 1
    maskcond[i] <- ceiling(cond/7)
    targetamp[i] <- abs(EEGallconds[s,1,cond])
    maskamp[i] <- abs(EEGallconds[s,2,cond])
  }
}
anovadata <- data.frame(subj,targetcond,maskcond,targetamp,maskamp)
anovadata$subj <- as.factor(anovadata$subj)
anovadata$targetcond <- as.factor(anovadata$targetcond)
anovadata$maskcond <- as.factor(anovadata$maskcond)

maskinganova1 <- ezANOVA(anovadata, dv=targetamp, wid=subj, within=c(targetcond,maskcond))

anovadataM <- subset(anovadata,maskcond==2)
maskinganova2 <- ezANOVA(anovadataM, dv=maskamp, wid=subj, within=targetcond)
gg <- maskinganova2$`Sphericity Corrections`$GGe

```

We began by reanalysing data from a steady-state visually evoked potential (SSVEP) experiment reported by @Vilidaite2018. Participants viewed arrays of flickering gratings of varying contrasts. In some conditions a single grating orientation was present flickering at 7Hz, whereas in other conditions a high contrast 'mask' was added at right angles to the target gratings, and flickering at 5Hz. The left panel of Figure \@ref(fig:Pilotdata)a shows contrast response functions with and without the mask - the presence of the mask reduces the 7Hz response to the target (blue squares are below the black circles; significant main effect of mask contrast, F(1,99) = `r round(maskinganova1$ANOVA$F[2],digits=2)`, \emph{p} < 0.001). Similarly, the right panel of Figure \@ref(fig:Pilotdata)a shows that the 5Hz response to the mask was itself suppressed by the presence of high contrast targets (main effect of target contrast on the mask response, F(`r round(maskinganova2$ANOVA$DFn*gg,digits=2)`,`r round(maskinganova2$ANOVA$DFd*gg,digits=2)`) = `r round(maskinganova2$ANOVA$F,digits=2)`, \emph{p} < 0.001; note that the data from the masking conditions were not reported by @Vilidaite2018). At both frequencies, responses were localised to the occipital pole (see insets).

```{r Pilotdata, fig.cap="Summary of pilot analysis of data from Vilidiate et al. (2018). Panel (a) shows contrast response functions at the target frequency (7Hz, left) and the mask frequency (5Hz, right). Insets show the distribution of activity across the scalp, with points marking the electrodes over which signals were averaged (Oz, POz, O1 and O2). Panel (b) shows Fourier spectra for the single component stimuli and their combination (plaid). Note the strong second harmonic components at 14Hz and 10Hz. Panel (c) shows timecourses of frequency-locked responses to a single stimulus (black) and the plaid stimulus (blue), compared to baseline (grey). Panel (d) shows the timecourse of suppression at each frequency (7Hz, 5Hz, 14Hz, 10Hz) and their average (black curve). Points around y = 1.8 indicate a significantly increasing ratio. Error bars in panel (a) and shaded regions in panels (c,d) indicate ±1SE across N=100 participants, and grey rectangles indicate the timing of stimulus presentation. The larger symbols in panel (a) indicate the conditions used for subsequent analyses.", fig.align="center", echo=FALSE}

knitr::include_graphics('Figures/VilidaiteData.pdf')

```

We then performed a timecourse analysis, in which we analysed each 11-second trial using a sliding 1-second time window. The top panel of Figure \@ref(fig:Pilotdata)c shows the response at the target frequency (7Hz) to a single stimulus of 32% contrast (black), and the response at 7Hz when the 32% contrast mask is added (blue). For comparison, a baseline timecourse is also shown (grey), which was the response at 7Hz when a 5Hz stimulus was shown (therefore controlling for attention, blinking etc.). Analogous responses are shown at three other frequencies - the mask frequency (5Hz), and the second harmonics of both target and mask frequencies (14Hz, 10Hz), at which strong responses were also found (see spectra in Figure \@ref(fig:Pilotdata)b). The reduction in signal strength when the mask component is added illustrates the masking effect. 

Taking the ratio of the two timecourses to calculate a masking index reveals that at 7Hz masking increases steeply during the first two seconds of stimulus presentation, and then plateaus for several seconds (blue trace in Figure \@ref(fig:Pilotdata)d). A similar pattern is observed at 5Hz (red trace in Figure \@ref(fig:Pilotdata)d), as well as at the second harmonics, with some variability in the timecourse across frequencies; for example at 5Hz suppression peaks at around 4 seconds. The black trace shows the average masking ratio across all four frequencies, which rises steeply for just over two seconds and then stays approximately constant until stimulus offset. We conducted cluster-corrected t-tests between ratios separated by `r timeoffset`ms, testing for an increase in suppression ratio across time (i.e. a one-sided test). Points at y = 1.8 in Figure \@ref(fig:Pilotdata)d indicate time points where the ratio is significantly increasing, and occur mostly during the first 2 seconds of stimulus presentation.

Our initial reanalysis was promising, however the data were noisy despite the large sample size (of N=100), because each participant contributed only 8 trials (88 seconds) to each condition. We therefore preregistered two new experiments (see https://osf.io/4qudc) to investigate these effects in greater detail. These had a similar overall design to the @Vilidaite2018 study, with some small changes intended to optimise the study (see Methods). The key differences were that we used shorter trials (because there were few changes in the latter part of the trials shown in Figure \@ref(fig:Pilotdata)d), and also focussed all trials into a smaller number of conditions, such that each participant contributed 48 repetitions (288 seconds of data) to each of 4 conditions.

```{r include=FALSE, results='hide'}

# analyse raw data from EEG study

samplerate <- 1000
targetF <- 5
maskF <- 7
duration <- 6
    binwidth <- 1000
    tindex <- 1 + targetF*(binwidth/samplerate)
    mindex <- 1 + maskF*(binwidth/samplerate)
    legaltriggers <- c(210,211,220,221,230,231,240,241)

 if (processdata>2){
   
osfproject <- osf_retrieve_node("ab3yv")
componentlist <- osf_ls_nodes(osfproject)
EEGID <- pmatch('Raw EEG data 1',as.character(unlist(componentlist[,1])))
EEGID[2] <- pmatch('Raw EEG data 2',as.character(unlist(componentlist[,1])))

subjcounter <- 0
for (datahalf in 1:length(EEGID)){
  EEGtoken <- componentlist[EEGID[datahalf],2]
  EEGfiles <- osf_ls_files(EEGtoken,n_max=300)
  for (f in 1:nrow(EEGfiles)){
    subjcounter <- subjcounter + 1
    print(subjcounter)
    # first check if we have this participant's data
    if (!file.exists(paste0('temp/EEGprocessed/S',subjcounter,'data.RData'))){
      # if we haven't processed the data, check if we need to download the raw data
      if (!dir.exists(paste0('temp/raw/S',subjcounter))){
        if (!file.exists(paste0('temp/raw/S',subjcounter,'.zip'))){
          osf_download(EEGfiles[f,], path='temp/raw/',progress=TRUE)
        }
          unzip(paste0('temp/raw/S',subjcounter,'.zip'),exdir='temp/raw/')
          file.remove(paste0('temp/raw/S',subjcounter,'.zip'))
      }
    # if necessary, process the data for this participant
      
      d <- dir(paste0('temp/raw/S',subjcounter), pattern='*.csv.gz',full.names=TRUE)
      condcounter <- (1:4) * 0
      alltrials <- array(0,dim=c(50,4,9000,64))
      subjwaves <- array(0,dim=c(4,9000,64))
      trialsincluded <- matrix(0,nrow=4,ncol=64)
      
      for (block in 1:length(d)){
      EEGdata <- read.csv(d[block], header = TRUE)
      electrodes <- colnames(EEGdata)

    triggertimes <- NULL
    counter <- 0
    for (n in 1:nrow(EEGdata)) {
      if (EEGdata$Trigger[n] %in% legaltriggers) {
        counter <- counter + 1
        triggertimes[counter] <- n
      }
    }
    
    # remove the first trial if there is not sufficient pre-trial baseline time
    if (triggertimes[1]<1500){triggertimes <- triggertimes[2:counter]}
    
     for (tr in 1:length(triggertimes)) {
      cond <- which(legaltriggers == EEGdata$Trigger[triggertimes[tr]])
      cond <- ceiling(cond/2)
      condcounter[cond] <- condcounter[cond] + 1

      # # horrible hack to fix one trial for P227
      # if (33-samplerate+(triggertimes[tr])<0){
      #   if (pno == 227){triggertimes[tr] <- triggertimes[tr] + 150}
      #   if (pno == 279){triggertimes[tr] <- triggertimes[tr] + 150}
      #  }
    for (ch in 1:64){     
      alltrials[condcounter[cond],cond,,ch] <- as.matrix(EEGdata[33-(1.5*samplerate)+(triggertimes[tr]:(triggertimes[tr] + samplerate * (3+duration) - 1)), ch+3])}
        
     }
        
      }
      
      for (cond in 1:4){
        for (ch in 1:64){
          
          temp <- alltrials[1:condcounter[cond],cond,,ch]
          
          spec5 <- NULL
          spec7 <- NULL
          for (t in 1:condcounter[cond]){
            spec <- fft(temp[t,1501:7500])
            spec5[t] <- spec[targetF*duration+1]
            spec7[t] <- spec[maskF*duration+1]
          }
        spec5[which(is.na(spec5))] <- 0
        spec7[which(is.na(spec7))] <- 0
      if (length(which(abs(spec5)>0))>2){  
      tempxy <- data.frame(Re(spec5),Im(spec5))
      D5 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
      tempxy <- data.frame(Re(spec7),Im(spec7))
      D7 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))      
      i <- which(D5<3 & D7<3)
      trialsincluded[cond,ch] <- length(i)
      subjwaves[cond,,ch] <- colMeans(temp[i,])
      }   
        }
      }
      
      
      qdatasubj <- read.csv(paste0('temp/raw/S',subjcounter,'/questionnairedata.csv'))
      save(file=paste0('temp/EEGprocessed/S',subjcounter,'data.RData'),list=c('qdatasubj','condcounter','trialsincluded','subjwaves','electrodes'))
    }
 }
}
   
 }

```
    
```{r include=FALSE, results='hide'}

# average EEG data across participants

if (processdata>1){    

d <- dir(path = 'temp/EEGprocessed', pattern = '*.RData', full.names=TRUE)

# download any missing data files from osf
if (length(d)<100){
  EEGrepo <- pmatch('Processed EEG data',as.character(unlist(componentlist[,1])))
  EEGfiles <- osf_ls_files(componentlist[EEGrepo,2],n_max=300)
  for (s in 1:length(EEGfiles)){
    if (!file.exists(paste0('temp/EEGProcessed/',EEGfiles[s,1]))){
      osf_download(EEGfiles[s,],'temp/EEGProcessed/',progress=TRUE)
    }
  }
}

d <- dir(path = 'temp/EEGprocessed', pattern = '*.RData', full.names=TRUE)

EEGtimecourse5Hz <- array(0,dim=c(length(d),4,8000))
EEGtimecourse7Hz <- array(0,dim=c(length(d),4,8000))
allwaves <- array(0,dim=c(length(d),4,9000))
allspec <- array(0,dim=c(length(d),4,duration*20))
allheads5 <- array(0,dim=c(length(d),4,64))
allheads7 <- array(0,dim=c(length(d),4,64))
EEGtrialsincluded <- array(0,dim=c(length(d),4,64))
allAQ <- NULL
allSPQ <- NULL
for (s in 1:length(d)){
  load(d[s])
  targetchannels <- match(targetelectrodes, electrodes) - 2
  EEGtrialsincluded[s,,] <- trialsincluded
  for (cond in 1:4){
    temp <- rowMeans(subjwaves[cond,,targetchannels],na.rm=TRUE)
    nainds <- which(is.na(temp))   # find occasional NaN values in the waveform
    # temp[nainds] <- (temp[nainds-1] + temp[nainds+1])/2   # interpolate adjacent values
    temp[nainds] <- 0   # replace with zeros
    allwaves[s,cond,] <- temp - mean(temp)
    spec <- fft(temp[1501:7500])/6000
    allspec[s,cond,] <- spec[1+(1:(duration*20))]

fspec1 <- NULL
fspec2 <- NULL
for (t in 1:(9000-binwidth)){
  spec <- fft(temp[t:(t+binwidth-1)])/binwidth
  fspec1[t] <- spec[tindex]
  fspec2[t] <- spec[mindex]
}
    EEGtimecourse5Hz[s,cond,] <- fspec1
    EEGtimecourse7Hz[s,cond,] <- fspec2


  for (ch in 1:64){
    temp <- fft(subjwaves[cond,1501:7500,ch])/6000
    allheads5[s,cond,ch] <- temp[1+(duration*targetF)]
    allheads7[s,cond,ch] <- temp[1+(duration*maskF)]
  }
  } 

allAQ[s] <- scoreAQ(qdatasubj[1,5:54]) 
allSPQ[s] <- scoreSPQ(qdatasubj[1,55:146])
}

save(file='temp/EEGsummary.RData',list=c('allheads5','allheads7','allspec','allwaves','EEGtimecourse5Hz','EEGtimecourse7Hz','electrodes','allAQ','allSPQ','EEGtrialsincluded'))
 }
   
```

```{r include=FALSE, results='hide'}

# bootstrapping and figure plotting for EEG data

 if (!file.exists('temp/EEGsummary.RData')){
      hid <- pmatch('EEGsummary.RData',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
 }

load('temp/EEGsummary.RData')

EEGpercentexcluded <- 100 - mean(100*EEGtrialsincluded[,,28:31]/48)

isincluded <- matrix(rep(1,4*dim(allspec)[1]),nrow=4,ncol=dim(allspec)[1])
for (cond in 1:4){
  # note that in allspec the DC component has been removed
  # so we don't need to add 1 to the index
      tempxy <- data.frame(Re(allspec[,cond,duration*targetF]),Im(allspec[,cond,duration*targetF]))
      D5 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
      tempxy <- data.frame(Re(allspec[,cond,duration*maskF]),Im(allspec[,cond,duration*maskF]))      
      D7 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))      
      isincluded[cond,which(D5>3)] <- 0
      isincluded[cond,which(D7>3)] <- 0
   for (s in 1:100){
     if (max(abs(EEGtimecourse5Hz[s,cond,]))>5){isincluded[cond,s] <- 0}
   }   
}

if (processdata>0){

allwaves[which(allwaves<(-100))] <- 0
allwaves[which(allwaves>100)] <- 0

EEGmeantime5Hz <- matrix(0,nrow=4,ncol=8000)
EEGmeantime7Hz <- matrix(0,nrow=4,ncol=8000)
EEGSEtime5Hz <- matrix(0,nrow=4,ncol=8000)
EEGSEtime7Hz <- matrix(0,nrow=4,ncol=8000)
meanspec <- matrix(0,nrow=4,ncol=120)
meanwave <- matrix(0,nrow=4,ncol=9000)
meanhead5 <- matrix(0,nrow=4,ncol=64)
meanhead7 <- matrix(0,nrow=4,ncol=64)
for (cond in 1:4){
EEGmeantime7Hz[cond,] <- apply(abs(EEGtimecourse7Hz[which(isincluded[cond,]==1),cond,]),2,mean,na.rm=TRUE)
EEGmeantime5Hz[cond,] <- apply(abs(EEGtimecourse5Hz[which(isincluded[cond,]==1),cond,]),2,mean,na.rm=TRUE)

EEGSEtime7Hz[cond,] <- apply(abs(EEGtimecourse7Hz[which(isincluded[cond,]==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(isincluded[cond,]))
EEGSEtime5Hz[cond,] <- apply(abs(EEGtimecourse5Hz[which(isincluded[cond,]==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(isincluded[cond,]))

meanspec[cond,] <- colMeans(abs(allspec[which(isincluded[cond,]==1),cond,]),na.rm=TRUE)
meanwave[cond,] <- colMeans(allwaves[which(isincluded[cond,]==1),cond,],na.rm=TRUE)
meanhead5[cond,] <- abs(colMeans(abs(allheads5[which(isincluded[cond,]==1),cond,]),na.rm=TRUE))
meanhead7[cond,] <- abs(colMeans(abs(allheads7[which(isincluded[cond,]==1),cond,]),na.rm=TRUE))
}

EEGmaskindex5 <- matrix(0,nrow=2,ncol=8000)
EEGmaskindexSE5 <- matrix(0,nrow=2,ncol=8000)
includedboth <- isincluded[1,]*isincluded[3,]
monratios <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),3,])
EEGmaskindex5[1,] <- colMeans(20*log10(monratios))
EEGmaskindexSE5[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
includedboth <- isincluded[1,]*isincluded[4,]
dichratios <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),4,])
EEGmaskindex5[2,] <- colMeans(20*log10(dichratios))
EEGmaskindexSE5[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))

earlydataM <- monratios*0
latedataM <- monratios*0
earlydataM[,1:(dim(monratios)[2]-(timeoffset/2))] <- monratios[,1:(dim(monratios)[2]-(timeoffset/2))]
earlydataM[,1:(timeoffset/2)] <- 0
latedataM[,(1+(timeoffset/2)):(dim(monratios)[2])] <- monratios[,1:(dim(monratios)[2]-(timeoffset/2))]
latedataM[1:dim(monratios)[1],(dim(monratios)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustoutM5 <- clustercorrect(earlydataM,latedataM,testtype=4,paired=TRUE)}

earlydataD <- dichratios*0
latedataD <- dichratios*0
earlydataD[,1:(dim(dichratios)[2]-(timeoffset/2))] <- dichratios[,1:(dim(dichratios)[2]-(timeoffset/2))]
earlydataD[,1:(timeoffset/2)] <- 0
latedataD[,(1+(timeoffset/2)):(dim(dichratios)[2])] <- dichratios[,1:(dim(dichratios)[2]-(timeoffset/2))]
latedataD[1:dim(dichratios)[1],(dim(dichratios)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustoutD5 <- clustercorrect(earlydataD,latedataD,testtype=4,paired=TRUE)}

EEGmaskindex7 <- matrix(0,nrow=2,ncol=8000)
EEGmaskindexSE7 <- matrix(0,nrow=2,ncol=8000)
includedboth <- isincluded[2,]*isincluded[3,]
monratios <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),3,])
EEGmaskindex7[1,] <- colMeans(20*log10(monratios))
EEGmaskindexSE7[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
includedboth <- isincluded[2,]*isincluded[4,]
dichratios <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),4,])
EEGmaskindex7[2,] <- colMeans(20*log10(dichratios))
EEGmaskindexSE7[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))

earlydataM <- monratios*0
latedataM <- monratios*0
earlydataM[,1:(dim(monratios)[2]-(timeoffset/2))] <- monratios[,1:(dim(monratios)[2]-(timeoffset/2))]
earlydataM[,1:(timeoffset/2)] <- 0
latedataM[,(1+(timeoffset/2)):(dim(monratios)[2])] <- monratios[,1:(dim(monratios)[2]-(timeoffset/2))]
latedataM[1:dim(monratios)[1],(dim(monratios)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustoutM7 <- clustercorrect(earlydataM,latedataM,testtype=4,paired=TRUE)}

earlydataD <- dichratios*0
latedataD <- dichratios*0
earlydataD[,1:(dim(dichratios)[2]-(timeoffset/2))] <- dichratios[,1:(dim(dichratios)[2]-(timeoffset/2))]
earlydataD[,1:(timeoffset/2)] <- 0
latedataD[,(1+(timeoffset/2)):(dim(dichratios)[2])] <- dichratios[,1:(dim(dichratios)[2]-(timeoffset/2))]
latedataD[1:dim(dichratios)[1],(dim(dichratios)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustoutD7 <- clustercorrect(earlydataD,latedataD,testtype=4,paired=TRUE)}

times <- ((1:8000)-1000)/1000

postscript("timecourse1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plotlims <- c(-1,7,0,0.6)
ticklocsx <- -1:7    # locations of tick marks on x axis
ticklocsy <- seq(0,0.6,0.1)    # locations of tick marks on y axis
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocsx, side = 1, at=ticklocsx)
mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,6,6,0),c(-0.022,-0.022,0.02,0.02),border=NA,col=rgb(0.5,0.5,0.5))

if (plotsmoothed==0){
polygon(times[c(1:8000,8000:1)],c(EEGmeantime5Hz[1,]+EEGSEtime5Hz[1,],EEGmeantime5Hz[1,8000:1]-EEGSEtime5Hz[1,8000:1]),col=colpal[1],border=NA)
polygon(times[c(1:8000,8000:1)],c(EEGmeantime5Hz[3,]+EEGSEtime5Hz[3,],EEGmeantime5Hz[3,8000:1]-EEGSEtime5Hz[3,8000:1]),col=colpal[2],border=NA)
polygon(times[c(1:8000,8000:1)],c(EEGmeantime5Hz[4,]+EEGSEtime5Hz[4,],EEGmeantime5Hz[4,8000:1]-EEGSEtime5Hz[4,8000:1]),col=colpal[3],border=NA)

lines(times,EEGmeantime5Hz[1,],lwd=2,col=colpal[1])
# lines(times,EEGmeantime5Hz[2,],lwd=2,col='green')
lines(times,EEGmeantime5Hz[3,],lwd=2,col=colpal[2])
lines(times,EEGmeantime5Hz[4,],lwd=2,col=colpal[3])
}

if (plotsmoothed==1){
spl5aU <- smooth.spline(times,EEGmeantime5Hz[1,]+EEGSEtime5Hz[1,],df=20)
spl5aL <- smooth.spline(times,EEGmeantime5Hz[1,]-EEGSEtime5Hz[1,],df=20)
polygon(times[c(1:8000,8000:1)],c(spl5aU$y,spl5aL$y[8000:1]),col=colpal[1],border=NA)

spl5cU <- smooth.spline(times,EEGmeantime5Hz[3,]+EEGSEtime5Hz[3,],df=20)
spl5cL <- smooth.spline(times,EEGmeantime5Hz[3,]-EEGSEtime5Hz[3,],df=20)
polygon(times[c(1:8000,8000:1)],c(spl5cU$y,spl5cL$y[8000:1]),col=colpal[2],border=NA)

spl5dU <- smooth.spline(times,EEGmeantime5Hz[4,]+EEGSEtime5Hz[4,],df=20)
spl5dL <- smooth.spline(times,EEGmeantime5Hz[4,]-EEGSEtime5Hz[4,],df=20)
polygon(times[c(1:8000,8000:1)],c(spl5dU$y,spl5dL$y[8000:1]),col=colpal[3],border=NA)

spl5a <- smooth.spline(times,EEGmeantime5Hz[1,],df=20)
lines(spl5a$x,spl5a$y,col=colpal[1],lwd=2)
# spl5b <- smooth.spline(times,EEGmeantime5Hz[2,],df=20)
# lines(spl5b$x,spl5b$y,col='green',lwd=2)
spl5c <- smooth.spline(times,EEGmeantime5Hz[3,],df=20)
lines(spl5c$x,spl5c$y,col=colpal[2],lwd=2)
spl5d <- smooth.spline(times,EEGmeantime5Hz[4,],df=20)
lines(spl5d$x,spl5d$y,col=colpal[3],lwd=2)

}
text(6,0.55,'5Hz',cex=2)
  legend(1.25,0.2,c('Baseline','Monocular','Dichoptic'),lty=1,lwd=2,col=colpal[1:3],box.lwd=2)
dev.off()

postscript("timecourse3.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plotlims <- c(-1,7,0,0.6)
ticklocsy <- seq(0,0.6,0.1)    # locations of tick marks on y axis
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocsx, side = 1, at=ticklocsx)
mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,6,6,0),c(-0.022,-0.022,0.02,0.02),border=NA,col=rgb(0.5,0.5,0.5))

if (plotsmoothed==0){
polygon(times[c(1:8000,8000:1)],c(EEGmeantime7Hz[2,]+EEGSEtime7Hz[2,],EEGmeantime7Hz[2,8000:1]-EEGSEtime7Hz[2,8000:1]),col=colpal[1],border=NA)
polygon(times[c(1:8000,8000:1)],c(EEGmeantime7Hz[3,]+EEGSEtime7Hz[3,],EEGmeantime7Hz[3,8000:1]-EEGSEtime7Hz[3,8000:1]),col=colpal[2],border=NA)
polygon(times[c(1:8000,8000:1)],c(EEGmeantime7Hz[4,]+EEGSEtime7Hz[4,],EEGmeantime7Hz[4,8000:1]-EEGSEtime7Hz[4,8000:1]),col=colpal[3],border=NA)
  
# lines(times,EEGmeantime7Hz[1,],lwd=2,col=colpal[1])
lines(times,EEGmeantime7Hz[2,],lwd=2,col=colpal[1])
lines(times,EEGmeantime7Hz[3,],lwd=2,col=colpal[2])
lines(times,EEGmeantime7Hz[4,],lwd=2,col=colpal[3])
}
if (plotsmoothed==1){
  
spl7bU <- smooth.spline(times,EEGmeantime7Hz[2,]+EEGSEtime7Hz[2,],df=20)
spl7bL <- smooth.spline(times,EEGmeantime7Hz[2,]-EEGSEtime7Hz[2,],df=20)
polygon(times[c(1:8000,8000:1)],c(spl7bU$y,spl7bL$y[8000:1]),col=colpal[1],border=NA)

spl7cU <- smooth.spline(times,EEGmeantime7Hz[3,]+EEGSEtime7Hz[3,],df=20)
spl7cL <- smooth.spline(times,EEGmeantime7Hz[3,]-EEGSEtime7Hz[3,],df=20)
polygon(times[c(1:8000,8000:1)],c(spl7cU$y,spl7cL$y[8000:1]),col=colpal[2],border=NA)

spl7dU <- smooth.spline(times,EEGmeantime7Hz[4,]+EEGSEtime7Hz[4,],df=20)
spl7dL <- smooth.spline(times,EEGmeantime7Hz[4,]-EEGSEtime7Hz[4,],df=20)
polygon(times[c(1:8000,8000:1)],c(spl7dU$y,spl7dL$y[8000:1]),col=colpal[3],border=NA)

# spl7a <- smooth.spline(times,EEGmeantime7Hz[1,],df=20)
# lines(spl7a$x,spl7a$y,col=colpal[1],lwd=2)
spl7b <- smooth.spline(times,EEGmeantime7Hz[2,],df=20)
lines(spl7b$x,spl7b$y,col=colpal[1],lwd=2)
spl7c <- smooth.spline(times,EEGmeantime7Hz[3,],df=20)
lines(spl7c$x,spl7c$y,col=colpal[2],lwd=2)
spl7d <- smooth.spline(times,EEGmeantime7Hz[4,],df=20)
lines(spl7d$x,spl7d$y,col=colpal[3],lwd=2)
}
text(6,0.55,'7Hz',cex=2)

dev.off()



postscript("timecourse2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plotlims <- c(-1,7,-3,7)
ticklocsy <- seq(-3,6,3)    # locations of tick marks on y axis
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocsx, side = 1, at=ticklocsx)
mtext(text = c(expression(sqrt(2)/2),'1',expression(sqrt(2)),'2'), side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Suppression ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,6,6,0),c(-3.4,-3.4,-2.6,-2.6),border=NA,col=rgb(0.5,0.5,0.5))

lines(c(-1,7),c(0,0),lty=2)

if (plotsmoothed==0){
polygon(times[c(1:8000,8000:1)],c(EEGmaskindex5[1,]+EEGmaskindexSE5[1,],EEGmaskindex5[1,8000:1]-EEGmaskindexSE5[1,8000:1]),col=colpal[2],border=NA)
polygon(times[c(1:8000,8000:1)],c(EEGmaskindex5[2,]+EEGmaskindexSE5[2,],EEGmaskindex5[1,8000:1]-EEGmaskindexSE5[2,8000:1]),col=colpal[3],border=NA)

lines(times,EEGmaskindex5[1,],col=colpal[2],lwd=2)
lines(times,EEGmaskindex5[2,],col=colpal[3],lwd=2)
}
if (plotsmoothed==1){
U <- smooth.spline(times,EEGmaskindex5[1,]+EEGmaskindexSE5[1,],df=20)
L <- smooth.spline(times,EEGmaskindex5[1,]-EEGmaskindexSE5[1,],df=20)
polygon(times[c(1:8000,8000:1)],c(U$y,L$y[8000:1]),col=colpal[2],border=NA)

U <- smooth.spline(times,EEGmaskindex5[2,]+EEGmaskindexSE5[2,],df=20)
L <- smooth.spline(times,EEGmaskindex5[2,]-EEGmaskindexSE5[2,],df=20)
polygon(times[c(1:8000,8000:1)],c(U$y,L$y[8000:1]),col=colpal[3],border=NA)

L <- smooth.spline(times,EEGmaskindex5[1,],df=20)
lines(L$x,L$y,col=colpal[2],lwd=2)
L <- smooth.spline(times,EEGmaskindex5[2,],df=20)
lines(L$x,L$y,col=colpal[3],lwd=2)
}

  if (nbootstraps>0){
    for (n in 1:clustoutM5$nclusters){
      temp <- unlist(clustoutM5$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-2, -2),lwd=3,col=colpal[2])
    }
        for (n in 1:clustoutD5$nclusters){
      temp <- unlist(clustoutD5$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=3,col=colpal[3])
    }
  }

dev.off()


postscript("timecourse4.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)

plotlims <- c(-1,7,-3,6)
ticklocsy <- seq(-3,6,3)    # locations of tick marks on y axis
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklocsx, side = 1, at=ticklocsx)
mtext(text = c(expression(sqrt(2)/2),'1',expression(sqrt(2)),'2'), side = 2, at=ticklocsy, line=0.2, las=1)
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
title(ylab="Suppression ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

polygon(c(0,6,6,0),c(-3.4,-3.4,-2.6,-2.6),border=NA,col=rgb(0.5,0.5,0.5))

lines(c(-1,7),c(0,0),lty=2)

if (plotsmoothed==0){
polygon(times[c(1:8000,8000:1)],c(EEGmaskindex7[1,]+EEGmaskindexSE7[1,],EEGmaskindex7[1,8000:1]-EEGmaskindexSE7[1,8000:1]),col=colpal[2],border=NA)
polygon(times[c(1:8000,8000:1)],c(EEGmaskindex7[2,]+EEGmaskindexSE7[2,],EEGmaskindex7[2,8000:1]-EEGmaskindexSE7[2,8000:1]),col=colpal[3],border=NA)

lines(times,EEGmaskindex7[1,],col=colpal[2],lwd=2)
lines(times,EEGmaskindex7[2,],col=colpal[3],lwd=2)
}

if (plotsmoothed==1){
U <- smooth.spline(times,EEGmaskindex7[1,]+EEGmaskindexSE7[1,],df=20)
L <- smooth.spline(times,EEGmaskindex7[1,]-EEGmaskindexSE7[1,],df=20)
polygon(times[c(1:8000,8000:1)],c(U$y,L$y[8000:1]),col=colpal[2],border=NA)

U <- smooth.spline(times,EEGmaskindex7[2,]+EEGmaskindexSE7[2,],df=20)
L <- smooth.spline(times,EEGmaskindex7[2,]-EEGmaskindexSE7[2,],df=20)
polygon(times[c(1:8000,8000:1)],c(U$y,L$y[8000:1]),col=colpal[3],border=NA)

L <- smooth.spline(times,EEGmaskindex7[1,],df=20)
lines(L$x,L$y,col=colpal[2],lwd=2)
L <- smooth.spline(times,EEGmaskindex7[2,],df=20)
lines(L$x,L$y,col=colpal[3],lwd=2)
}

  if (nbootstraps>0){
    for (n in 1:clustoutM7$nclusters){
      temp <- unlist(clustoutM7$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-2, -2),lwd=3,col=colpal[2])
    }
        for (n in 1:clustoutD7$nclusters){
      temp <- unlist(clustoutD7$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=3,col=colpal[3])
    }
  }

dev.off()


freqlist <- seq(1/6,20,length=ncol(meanspec))

postscript("spectrum.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 10)

plotlims <- c(0,20,0,4)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(0,20,5)    # locations of tick marks on x axis
ticklocsy <- c(0,0.4,0.8,1,2,3,4)    # locations of tick marks on y axis
ticklabelsx <- seq(0,20,5)        # set labels for x ticks
ticklabelsy <- c(0,0.2,0.4,'','','','')    # set labels for y ticks
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)

lines(c(0,20),c(0,0),lty=3)
lines(c(0,20),c(1,1),lty=3)
lines(c(0,20),c(2,2),lty=3)
lines(c(0,20),c(3,3),lty=3)

# lines(c(5,5),c(0,4),col='grey',lwd=2)
# lines(c(7,7),c(0,4),col='grey',lwd=2)

polygon(c(1,freqlist[6:120],20),c(0,2*meanspec[1,6:120],0)+3,border=NA,col=colpal[1])
polygon(c(1,freqlist[6:120],20),c(0,2*meanspec[2,6:120],0)+2,border=NA,col=colpal[1])
polygon(c(1,freqlist[6:120],20),c(0,2*meanspec[3,6:120],0)+1,border=NA,col=colpal[2])
polygon(c(1,freqlist[6:120],20),c(0,2*meanspec[4,6:120],0),border=NA,col=colpal[3])

lines(freqlist[6:120],2*meanspec[1,6:120]+3,lwd=2,col='black')
lines(freqlist[6:120],2*meanspec[2,6:120]+2,lwd=2,col='black')
lines(freqlist[6:120],2*meanspec[3,6:120]+1,lwd=2,col='black')
lines(freqlist[6:120],2*meanspec[4,6:120],lwd=2,col='black')

text(20,3.5,'5Hz monocular target',pos=2,cex=1.5)
text(20,2.5,'7Hz monocular target',pos=2,cex=1.5)
text(20,1.5,'Monocular combination',pos=2,cex=1.5)
text(20,0.5,'Dichoptic combination',pos=2,cex=1.5)

dev.off()


times <- seq(1/1000,9,1/1000)-1.5
trigwaveform1 <- -cos(2 * 5 * times * pi)
trigwaveform2 <- -cos(2 * 7 * times * pi)
trigwaveform1[1:1500] <- -1
trigwaveform1[7501:9000] <- -1
trigwaveform2[1:1500] <- -1
trigwaveform2[7501:9000] <- -1

postscript("waveform1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 12)

plotlims <- c(-1,7,-3,2)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-1,7,1)    # locations of tick marks on x axis
ticklocsy <- seq(-3,2,1)    # locations of tick marks on y axis
ticklabelsx <- seq(-1,7,1)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
polygon(c(0,6,6,0,0),c(-3,-3,2,2,-2),col=rgb(0.95,0.95,0.95),border=NA)

lines(times[501:8500],meanwave[1,501:8500],lwd=1,col=colpal[2])
lines(times[501:8500],(trigwaveform1[501:8500]/2) - 2.5)
# text(-1,1.8,'5Hz average waveform',pos=4,cex=1.5)

dev.off()

postscript("waveform2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 12)

plotlims <- c(-1,7,-3,2)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
ticklocsx <- seq(-1,7,1)    # locations of tick marks on x axis
ticklocsy <- seq(-3,2,1)    # locations of tick marks on y axis
ticklabelsx <- seq(-1,7,1)        # set labels for x ticks
ticklabelsy <- ticklocsy    # set labels for y ticks
plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1)  
title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
title(ylab="Amplitude (µV)", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
polygon(c(0,6,6,0,0),c(-3,-3,2,2,-2),col=rgb(0.95,0.95,0.95),border=NA)

lines(times[501:8500],meanwave[2,501:8500],lwd=1,col=colpal[2])
lines(times[501:8500],(trigwaveform2[501:8500]/2) - 2.5)
# text(-1,1.8,'7Hz average waveform',pos=4,cex=1.5)

dev.off()

xpos <- 1:64
ypos <- 1:64
montageE <- toupper(as.character(hdata$Electrode))
for (ch in 1:64){
  i <- match(toupper(electrodes[ch+2]),montageE)
  xpos[ch] <- hdata$X_position[i]
  ypos[ch] <- hdata$Y_position[i]
}


rmax <- 0.55   #specify a maximum boundary for the grid
gridRes <- 100 #specify the interpolation grid resolution

datatoplot <- meanhead5[1,]
datatoplot[which(is.na(datatoplot))] <- 0
datatoplot[which(datatoplot<0)] <- 0
datatoplot[which(datatoplot>30)] <- 0

testDat<- data.frame(x = xpos,
                     y = -ypos,
                     z = datatoplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0

ramp2 <- colorRamp(c("white",colpal[2]))  
colmatrix2 <- rgb(ramp2(seq(0, 1, length = 101)), max = 255)


tiff('headplot1.tif', height = 600, width = 600, units="px", bg="white")
    
plotlims <- c(-rmax,rmax,-rmax,rmax)  
par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4]) 
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=FALSE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match('OZ',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('POZ',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('O1',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('O2',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

# text(0,-0.55,'5Hz response',cex=1.5,adj=0.5)

dev.off()

datatoplot <- meanhead7[2,]
datatoplot[which(is.na(datatoplot))] <- 0
datatoplot[which(datatoplot<0)] <- 0
datatoplot[which(datatoplot>30)] <- 0

testDat<- data.frame(x = xpos,
                     y = -ypos,
                     z = datatoplot)

#Create the interpolation grid
xo <- seq(min(-rmax, testDat$x), max(rmax, testDat$x), length = gridRes)
yo <- seq(max(rmax, testDat$y), min(-rmax, testDat$y), length = gridRes)

interpV4 <- v4Interp(testDat, xo, yo, rmax, gridRes)

zo2 <- as.matrix(interpV4[,2:ncol(interpV4)])

xo2 <- matrix(rep(xo,length(yo)),nrow = length(xo),ncol = length(yo))
yo2 <- t(matrix(rep(yo,length(xo)),nrow = length(yo),ncol = length(xo)))
outsidecircle <- sqrt(xo2^2 + yo2^2) > 0.51
zo2[outsidecircle] <- 0

tiff('headplot2.tif', height = 600, width = 600, units="px", bg="white")

par(pty="s")  # make axis square
plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4]) 
image(xo,xo,zo2,col=colmatrix2,zlim=c(0,1),add=TRUE,useRaster=FALSE)
maskx <- c(hdata$OutlineX[1:51]*2.2,hdata$OutlineX[51:1])
masky <- c(hdata$OutlineY[1:51]*2.2,hdata$OutlineY[51:1])
polygon(maskx,masky,border=NA,col="white")
maskx <- c(hdata$OutlineX[51:101]*2.2,hdata$OutlineX[101:51])
masky <- c(hdata$OutlineY[51:101]*2.2,hdata$OutlineY[101:51])
polygon(maskx,masky,border=NA,col="white")

blackelectrodes <- match('OZ',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('POZ',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('O1',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)
blackelectrodes <- match('O2',toupper(as.character(electrodes[3:66])))
points(xpos[blackelectrodes],ypos[blackelectrodes],pch=16,col="black",cex=1.6)

lines(hdata$OutlineX,hdata$OutlineY,col="black",lwd=2)
lines(hdata$NoseX,hdata$NoseY,col="black",lwd=2)
lines(hdata$LearX,hdata$LearY,col="black",lwd=2)
lines(hdata$RearX,hdata$RearY,col="black",lwd=2)

# text(0,-0.55,'7Hz response',cex=1.5,adj=0.5)

dev.off()

# baseline <- data.frame(Re(allspec[,1,duration*targetF]),Im(allspec[,1,duration*targetF]))
# monmask <- data.frame(Re(allspec[,3,duration*targetF]),Im(allspec[,3,duration*targetF]))
# dichmask <- data.frame(Re(allspec[,4,duration*targetF]),Im(allspec[,4,duration*targetF]))
# 
# par(pty="s")  # make axis square
# plotlims <- c(-1,1,-1,1)
# plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4]) 
# lines(plotlims[1:2],c(0,0))
# lines(c(0,0),plotlims[1:2])
# 
# points(baseline[,1],baseline[,2],pch=16,cex=0.5,col=addalpha(colpal[1],0.2))
# points(monmask[,1],monmask[,2],pch=16,cex=0.5,col=addalpha(colpal[2],0.2))
# points(dichmask[,1],dichmask[,2],pch=16,cex=0.5,col=addalpha(colpal[3],0.2))
# 
# points(mean(baseline[,1]),mean(baseline[,2]),pch=16,cex=2,col=addalpha(colpal[1],1))
# points(mean(monmask[,1]),mean(monmask[,2]),pch=16,cex=2,col=addalpha(colpal[2],1))
# points(mean(dichmask[,1]),mean(dichmask[,2]),pch=16,cex=2,col=addalpha(colpal[3],1))
# 
# 
# 
# baseline <- data.frame(Re(allspec[,2,duration*maskF]),Im(allspec[,2,duration*maskF]))
# monmask <- data.frame(Re(allspec[,3,duration*maskF]),Im(allspec[,3,duration*maskF]))
# dichmask <- data.frame(Re(allspec[,4,duration*maskF]),Im(allspec[,4,duration*maskF]))
# 
# par(pty="s")  # make axis square
# plotlims <- c(-1,1,-1,1)
# plot(x=NULL,y=NULL,ann=FALSE, axes=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4]) 
# lines(plotlims[1:2],c(0,0))
# lines(c(0,0),plotlims[1:2])
# 
# points(baseline[,1],baseline[,2],pch=16,cex=0.5,col=addalpha(colpal[1],0.2))
# points(monmask[,1],monmask[,2],pch=16,cex=0.5,col=addalpha(colpal[2],0.2))
# points(dichmask[,1],dichmask[,2],pch=16,cex=0.5,col=addalpha(colpal[3],0.2))
# 
# points(mean(baseline[,1]),mean(baseline[,2]),pch=16,cex=2,col=addalpha(colpal[1],1))
# points(mean(monmask[,1]),mean(monmask[,2]),pch=16,cex=2,col=addalpha(colpal[2],1))
# points(mean(dichmask[,1]),mean(dichmask[,2]),pch=16,cex=2,col=addalpha(colpal[3],1))
# 


  e1 <- readTIFF('headplot1.tif')
  e2 <- readTIFF('headplot2.tif')

  PostScriptTrace(paste('waveform1.ps',sep=''))
  e3 <- readPicture('waveform1.ps.xml')
  PostScriptTrace(paste('waveform2.ps',sep=''))
  e4 <- readPicture('waveform2.ps.xml')
  
  PostScriptTrace(paste('spectrum.ps',sep=''))
  e5 <- readPicture('spectrum.ps.xml')
  for (n in 1:length(e5@paths)){
    temp <- class(e5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e5@paths[n]$path@rgb))<765){e5@paths[n]$path@rgb <- addalpha(e5@paths[n]$path@rgb,alpha=0.2)}}}

   PostScriptTrace(paste('timecourse1.ps',sep=''))
  e6 <- readPicture('timecourse1.ps.xml')
  for (n in 1:length(e6@paths)){
    temp <- class(e6@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e6@paths[n]$path@rgb))<765){e6@paths[n]$path@rgb <- addalpha(e6@paths[n]$path@rgb,alpha=0.2)}}}
 
   PostScriptTrace(paste('timecourse2.ps',sep=''))
  e7 <- readPicture('timecourse2.ps.xml')
  for (n in 1:length(e7@paths)){
    temp <- class(e7@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e7@paths[n]$path@rgb))<765){e7@paths[n]$path@rgb <- addalpha(e7@paths[n]$path@rgb,alpha=0.2)}}}

     PostScriptTrace(paste('timecourse3.ps',sep=''))
  e8 <- readPicture('timecourse3.ps.xml')
  for (n in 1:length(e8@paths)){
    temp <- class(e8@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e8@paths[n]$path@rgb))<765){e8@paths[n]$path@rgb <- addalpha(e8@paths[n]$path@rgb,alpha=0.2)}}}

     PostScriptTrace(paste('timecourse4.ps',sep=''))
  e9 <- readPicture('timecourse4.ps.xml')
  for (n in 1:length(e9@paths)){
    temp <- class(e9@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e9@paths[n]$path@rgb))<765){e9@paths[n]$path@rgb <- addalpha(e9@paths[n]$path@rgb,alpha=0.2)}}}
  
  
  
  pdf('Figures/EEGdata.pdf', bg="transparent", height = 6, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1)) 

  aspratio <- 6/15  # this is the aspect ratio of the output pdf
  imwidth <- 0.28
  xstart <- 0.02
  ystart <- 0.75
  rasterImage(e1,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)
  ystart <- 0.475
  rasterImage(e2,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)

  grid.picture(e3,x=0.3,y=0.85,width=0.3,height=1)
  grid.picture(e4,x=0.3,y=0.6,width=0.3,height=1)
  grid.picture(e5,x=0.25,y=0.25,width=0.45,height=1)

  grid.picture(e6,x=0.6,y=0.75,width=0.25,height=1)
  grid.picture(e7,x=0.85,y=0.75,width=0.25,height=1)
  grid.picture(e8,x=0.6,y=0.25,width=0.25,height=1)
  grid.picture(e9,x=0.85,y=0.25,width=0.25,height=1)
  
  text(-0.02,1,'(a)',pos=4,cex=2)
  text(-0.02,0.45,'(b)',pos=4,cex=2)
  text(0.515,1,'(c)',pos=4,cex=2)
  text(0.515,0.46,'(d)',pos=4,cex=2)
  text(0.785,1,'(e)',pos=4,cex=2)
  text(0.785,0.46,'(f)',pos=4,cex=2)
  
  text(-0.02,0.89,'5Hz',pos=4,cex=2)
  text(-0.02,0.61,'7Hz',pos=4,cex=2)

  dev.off()
  
  file.remove(c('headplot1.tif','headplot2.tif','spectrum.ps','timecourse1.ps','timecourse2.ps','timecourse3.ps','timecourse4.ps','waveform1.ps','waveform2.ps'))
  file.remove(c('spectrum.ps.xml','timecourse1.ps.xml','timecourse2.ps.xml','timecourse3.ps.xml','timecourse4.ps.xml','waveform1.ps.xml','waveform2.ps.xml'))

}
 
```

```{r include=FALSE, results='hide'}

# statistical testing

targetcond <- NULL
maskcond <- NULL
subj <- NULL
targetamp <- NULL
maskamp <- NULL
i <- 0
for (s in 1:100){

  if ((isincluded[1,s]*isincluded[3,s]*isincluded[4,s])==1){
    i <- i + 1
    subj[i] <- s
    targetcond[i] <- 5
    maskcond[i] <- 1
    targetamp[i] <- (allspec[s,1,duration*targetF])

    i <- i + 1
    subj[i] <- s
        targetcond[i] <- 5
    maskcond[i] <- 2
    targetamp[i] <- (allspec[s,3,duration*targetF])

    i <- i + 1
    subj[i] <- s
        targetcond[i] <- 5
    maskcond[i] <- 3
    targetamp[i] <- (allspec[s,4,duration*targetF])
  }
  if ((isincluded[2,s]*isincluded[3,s]*isincluded[4,s])==1){  
    i <- i + 1
    subj[i] <- s
    targetcond[i] <- 7
    maskcond[i] <- 1
    targetamp[i] <- (allspec[s,2,duration*maskF])

    i <- i + 1
    subj[i] <- s
        targetcond[i] <- 7
    maskcond[i] <- 2
    targetamp[i] <- (allspec[s,3,duration*maskF])

    i <- i + 1
    subj[i] <- s
        targetcond[i] <- 7
    maskcond[i] <- 3
    targetamp[i] <- (allspec[s,4,duration*maskF])
  }
}
alldata <- data.frame(subj,targetcond,maskcond,targetamp)
alldata$subj <- as.factor(alldata$subj)
alldata$targetcond <- as.factor(alldata$targetcond)
alldata$maskcond <- as.factor(alldata$maskcond)

all5 <- subset(alldata,targetcond==5)
all7 <- subset(alldata,targetcond==7)

baseline5 <- subset(all5,maskcond==1)
baseline7 <- subset(all7,maskcond==1)
mon5 <- subset(all5,maskcond==2)
mon7 <- subset(all7,maskcond==2)
dich5 <- subset(all5,maskcond==3)
dich7 <- subset(all7,maskcond==3)


# tsqc.test(baseline7$targetamp,mon7$targetamp,paired=TRUE)
# tsqc.test(baseline7$targetamp,dich7$targetamp,paired=TRUE)
# tsqc.test(mon7$targetamp,dich7$targetamp,paired=TRUE)
# 
# tsqc.test(baseline5$targetamp,mon5$targetamp,paired=TRUE)
# tsqc.test(baseline5$targetamp,dich5$targetamp,paired=TRUE)
# tsqc.test(mon5$targetamp,dich5$targetamp,paired=TRUE)

t7a <- t.test(abs(baseline7$targetamp),abs(mon7$targetamp),paired=TRUE)
t7b <- t.test(abs(baseline7$targetamp),abs(dich7$targetamp),paired=TRUE)
t7c <- t.test(abs(mon7$targetamp),abs(dich7$targetamp),paired=TRUE)

t5a <- t.test(abs(baseline5$targetamp),abs(mon5$targetamp),paired=TRUE)
t5b <- t.test(abs(baseline5$targetamp),abs(dich5$targetamp),paired=TRUE)
t5c <- t.test(abs(mon5$targetamp),abs(dich5$targetamp),paired=TRUE)


```

Figure \@ref(fig:EEGdata) summarises the results of our EEG experiment testing a further 100 adult participants. Averaged EEG waveforms showed a strong oscillatory component at each of the two stimulus flicker frequencies (Figure \@ref(fig:EEGdata)a), which slightly lagged the driving signal. Signals were well-isolated in the Fourier domain (Figure \@ref(fig:EEGdata)b), and localised to occipital electrodes. Responses at 7Hz were weaker in the two masking conditions, showing significant changes in response amplitude for both the monocular (\emph{t} = `r round(t7a$statistic,digits=2)`, \emph{df} = `r t7a$parameter`, \emph{p} < 0.001) and dichoptic (\emph{t} = `r round(t7b$statistic,digits=2)`, \emph{df} = `r t7b$parameter`, \emph{p} < 0.001) masks. Dichoptic masking was significantly stronger than monocular masking (\emph{t} = `r round(t7c$statistic,digits=2)`, \emph{df} = `r t7c$parameter`, \emph{p} < 0.001), and a similar pattern was evident at 5Hz.

```{r EEGdata, fig.cap="Summary of EEG results for N=100 adult participants. Panel (a) shows scalp topographies and averaged waveforms for 5Hz (top) and 7Hz (bottom) stimuli. The black sine wave trace in each panel illustrates the driving contrast modulation, and black points on the scalp topographies indicate electrodes Oz, O1, O2 and POz. Panel (b) shows the Fourier amplitude spectrum for each condition, with clear peaks at 5Hz and 7Hz. Panels (c,d) show timecourses at each frequency for the baseline condition (black), and the monocular (blue) and dichoptic (red) masking conditions. Panels (e,f) show suppression ratios as a function of time for each mask type, with points around y = 0.8 indicating a significantly increasing ratio. Shaded regions in panels (c-f) span ±1SE across participants, and light grey rectangles indicate the period of stimulus presentation.", fig.align="center", echo=FALSE}

knitr::include_graphics('Figures/EEGdata.pdf')

```

The timecourse at both flicker frequencies showed an initial onset transient, and was then relatively stable for the 6 seconds of stimulus presentation (Figure \@ref(fig:EEGdata)c,d). The ratio of target only to target + mask conditions increased over time (Figure \@ref(fig:EEGdata)e,f) for both mask types. At 5Hz the increase in masking continued over the first 5 seconds of stimulus presentation (Figure \@ref(fig:EEGdata)e; points at y = 0.8 indicate significantly increasing suppression), whereas at 7Hz the increase occurred primarily during the first second after onset (Figure \@ref(fig:EEGdata)f). These differences across frequency are consistent with the pilot data (see Figure \@ref(fig:Pilotdata)d). Both monocular and dichoptic masks produced similar timecourses of suppression. Overall, this second study confirmed that normalization increases during the first few seconds of a steady-state trial, and extends this finding to dichoptic mask arrangements.

```{r include=FALSE, results='hide'}

# combine MEG data across participants

samplerate <- 1001
targetF <- 5
maskF <- 7
duration <- 6
    binwidth <- 1001
    tindex <- 1 + targetF*(binwidth/samplerate)
    mindex <- 1 + maskF*(binwidth/samplerate)

if (processdata>1){
  
  d <- dir(path = 'temp/MEGdata/', pattern = '*data.RData', full.names=TRUE)

  # download any missing data files from osf
if (length(d)<20){
  MEGrepo <- pmatch('Processed MEG data',as.character(unlist(componentlist[,1])))
  MEGfiles <- osf_ls_files(componentlist[MEGrepo,2],n_max=300)
  for (s in 1:length(MEGfiles)){
    if (!file.exists(paste0('temp/MEGdata/',MEGfiles[s,1]))){
      osf_download(MEGfiles[s,],'temp/MEGdata/',progress=TRUE)
    }
  }
}
  
   d <- dir(path = 'temp/MEGdata/', pattern = '*data.RData', full.names=TRUE)

  MEGtimecourse5Hz <- array(0,dim=c(length(d),4,8008))
  MEGtimecourse7Hz <- array(0,dim=c(length(d),4,8008))
  MEGtrialsincluded <- matrix(0,nrow=20,ncol=4)
  MEGsubjwaves <- array(0,dim=c(length(d),4,9009))
  allspec <- array(0,dim=c(length(d),4,duration*20))
  MEGallAQ <- NULL
  MEGallSPQ <- NULL
  MEGallAge <- NULL
  MEGallGender <- NULL
  MEGallDiagnosis <- NULL
  for (s in 1:length(d)){

    load(d[s])
    
    MEGallAge[s] <- qdatasubj[1,1]
    MEGallGender[s] <- qdatasubj[1,2]
    MEGallDiagnosis[s] <- qdatasubj[1,3]
    if (qdatasubj[1,5]!=0){
    MEGallAQ[s] <- scoreAQ(qdatasubj[1,5:54])
    MEGallSPQ[s] <- scoreSPQ(qdatasubj[1,55:146])
    }
    if (qdatasubj[1,5]==0){MEGallAQ[s] <- 999
    MEGallSPQ[s] <- 999}
    
      for (cond in 1:4){
          
          temp <- alltrials[cond,1:trialcounter[1,cond],]
          spec5 <- NULL
          spec7 <- NULL
          for (t in 1:trialcounter[1,cond]){
            spec <- fft(temp[t,1501:7506])/6006
            spec5[t] <- spec[targetF*duration+1]
            spec7[t] <- spec[maskF*duration+1]
          }
        spec5[which(is.na(spec5))] <- 0
        spec7[which(is.na(spec7))] <- 0
      if (length(which(abs(spec5)>0))>2){  
      tempxy <- data.frame(Re(spec5),Im(spec5))
      D5 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
      tempxy <- data.frame(Re(spec7),Im(spec7))
      D7 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))      
      i <- which(D5<3 & D7<3)
      MEGtrialsincluded[s,cond] <- length(i)
      temp <- colMeans(temp[i,])
      MEGsubjwaves[s,cond,] <- temp
      spec <- fft(temp[1501:7506])/6006
      allspec[s,cond,] <- spec[1+(1:(duration*20))]
      
        fspec1 <- NULL
        fspec2 <- NULL
        for (t in 1:(9009-binwidth)){
          spec <- fft(temp[t:(t+binwidth-1)])/binwidth
          fspec1[t] <- spec[tindex]
          fspec2[t] <- spec[mindex]
        }

        MEGtimecourse5Hz[s,cond,] <- fspec1
        MEGtimecourse7Hz[s,cond,] <- fspec2
        
      }   
      }    
    
    
  }
  
  save(file='temp/MEGsummary.RData',list=c('allspec','MEGtimecourse5Hz','MEGtimecourse7Hz','MEGtrialsincluded','MEGallAge','MEGallGender','MEGallDiagnosis','MEGallAQ','MEGallSPQ'))

}

```
    
```{r include=FALSE, results='hide'}

# plot MEG figure

 if (!file.exists('temp/MEGsummary.RData')){
      hid <- pmatch('MEGsummary.RData',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
 }

load('temp/MEGsummary.RData')
MEGpercentexcluded <- 100 - (100*mean(MEGtrialsincluded)/48)

if (processdata>0){
  
  isincluded <- array(1, dim=c(4,dim(allspec)[1]))
    for (cond in 1:4){
      # note that in allspec the DC component has been removed
      # so we don't need to add 1 to the index
      tempxy <- data.frame(Re(allspec[,cond,duration*targetF]),Im(allspec[,cond,duration*targetF]))
      D5 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
      tempxy <- data.frame(Re(allspec[,cond,duration*maskF]),Im(allspec[,cond,duration*maskF]))      
      D7 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))      
      isincluded[cond,which(D5>3)] <- 0
      isincluded[cond,which(D7>3)] <- 0
      for (s in 1:20){
        if (max(abs(MEGtimecourse5Hz[s,cond,]))>5){isincluded[cond,s] <- 0}
      }   
    }
  
  MEGmeantime5Hz <- array(0,dim=c(4,8008))
  MEGmeantime7Hz <- array(0,dim=c(4,8008))
  MEGSEtime5Hz <- array(0,dim=c(4,8008))
  MEGSEtime7Hz <- array(0,dim=c(4,8008))
  meanspec <- array(0,dim=c(4,120))

    for (cond in 1:4){
      MEGmeantime7Hz[cond,] <- apply(abs(MEGtimecourse7Hz[which(isincluded[cond,]==1),cond,]),2,mean,na.rm=TRUE)
      MEGmeantime5Hz[cond,] <- apply(abs(MEGtimecourse5Hz[which(isincluded[cond,]==1),cond,]),2,mean,na.rm=TRUE)
      
      MEGSEtime7Hz[cond,] <- apply(abs(MEGtimecourse7Hz[which(isincluded[cond,]==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(isincluded[cond,]))
      MEGSEtime5Hz[cond,] <- apply(abs(MEGtimecourse5Hz[which(isincluded[cond,]==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(isincluded[cond,]))
      
      meanspec[cond,] <- colMeans(abs(allspec[which(isincluded[cond,]==1),cond,]),na.rm=TRUE)
    }

  
  MEGmaskindex5 <- array(0, dim=c(2,8008))
  MEGmaskindexSE5 <- array(0, dim=c(2,8008))
  MEGmaskindex7 <- array(0, dim=c(2,8008))
  MEGmaskindexSE7 <- array(0, dim=c(2,8008))

    includedboth <- isincluded[1,]*isincluded[3,]
    monratios <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),3,])
    MEGmaskindex5[1,] <- colMeans(20*log10(monratios))
    MEGmaskindexSE5[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
    includedboth <- isincluded[1,]*isincluded[4,]
    dichratios <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),4,])
    MEGmaskindex5[2,] <- colMeans(20*log10(dichratios))
    MEGmaskindexSE5[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
    
    earlydataM <- monratios*0
latedataM <- monratios*0
earlydataM[,1:(dim(monratios)[2]-(timeoffset/2))] <- monratios[,1:(dim(monratios)[2]-(timeoffset/2))]
earlydataM[,1:(timeoffset/2)] <- 0
latedataM[,(1+(timeoffset/2)):(dim(monratios)[2])] <- monratios[,1:(dim(monratios)[2]-(timeoffset/2))]
latedataM[1:dim(monratios)[1],(dim(monratios)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustoutM5 <- clustercorrect(earlydataM,latedataM,testtype=4,paired=TRUE)}

earlydataD <- dichratios*0
latedataD <- dichratios*0
earlydataD[,1:(dim(dichratios)[2]-(timeoffset/2))] <- dichratios[,1:(dim(dichratios)[2]-(timeoffset/2))]
earlydataD[,1:(timeoffset/2)] <- 0
latedataD[,(1+(timeoffset/2)):(dim(dichratios)[2])] <- dichratios[,1:(dim(dichratios)[2]-(timeoffset/2))]
latedataD[1:dim(dichratios)[1],(dim(dichratios)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustoutD5 <- clustercorrect(earlydataD,latedataD,testtype=4,paired=TRUE)}

    includedboth <- isincluded[2,]*isincluded[3,]
    monratios <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),3,])
    MEGmaskindex7[1,] <- colMeans(20*log10(monratios))
    MEGmaskindexSE7[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
    includedboth <- isincluded[2,]*isincluded[4,]
    dichratios <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),4,])
    MEGmaskindex7[2,] <- colMeans(20*log10(dichratios))
    MEGmaskindexSE7[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))

  earlydataM <- monratios*0
latedataM <- monratios*0
earlydataM[,1:(dim(monratios)[2]-(timeoffset/2))] <- monratios[,1:(dim(monratios)[2]-(timeoffset/2))]
earlydataM[,1:(timeoffset/2)] <- 0
latedataM[,(1+(timeoffset/2)):(dim(monratios)[2])] <- monratios[,1:(dim(monratios)[2]-(timeoffset/2))]
latedataM[1:dim(monratios)[1],(dim(monratios)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustoutM7 <- clustercorrect(earlydataM,latedataM,testtype=4,paired=TRUE)}

earlydataD <- dichratios*0
latedataD <- dichratios*0
earlydataD[,1:(dim(dichratios)[2]-(timeoffset/2))] <- dichratios[,1:(dim(dichratios)[2]-(timeoffset/2))]
earlydataD[,1:(timeoffset/2)] <- 0
latedataD[,(1+(timeoffset/2)):(dim(dichratios)[2])] <- dichratios[,1:(dim(dichratios)[2]-(timeoffset/2))]
latedataD[1:dim(dichratios)[1],(dim(dichratios)[2])+(1-(timeoffset/2)):0] <- 0

if (nbootstraps>0){clustoutD7 <- clustercorrect(earlydataD,latedataD,testtype=4,paired=TRUE)}

  times <- ((1:8008)-1001)/1001
  
  postscript("timecourse1.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
  
  plotlims <- c(-1,7,0,3)
  ticklocsx <- -1:7    # locations of tick marks on x axis
  ticklocsy <- seq(0,3,1)    # locations of tick marks on y axis
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklocsx, side = 1, at=ticklocsx)
  mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="Amplitude", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  
  polygon(c(0,6,6,0),c(-0.08,-0.08,0.1,0.1),border=NA,col=rgb(0.5,0.5,0.5))
  
  if (plotsmoothed==0){
    polygon(times[c(1:8008,8008:1)],100*c(MEGmeantime5Hz[1,]+MEGSEtime5Hz[1,],MEGmeantime5Hz[1,8008:1]-MEGSEtime5Hz[1,8008:1]),col=colpal[1],border=NA)
    polygon(times[c(1:8008,8008:1)],100*c(MEGmeantime5Hz[3,]+MEGSEtime5Hz[3,],MEGmeantime5Hz[3,8008:1]-MEGSEtime5Hz[3,8008:1]),col=colpal[2],border=NA)
    polygon(times[c(1:8008,8008:1)],100*c(MEGmeantime5Hz[4,]+MEGSEtime5Hz[4,],MEGmeantime5Hz[4,8008:1]-MEGSEtime5Hz[4,8008:1]),col=colpal[3],border=NA)
    
    lines(times,100*MEGmeantime5Hz[1,],lwd=2,col=colpal[1])
    # lines(times,MEGmeantime5Hz[2,],lwd=2,col='green')
    lines(times,100*MEGmeantime5Hz[3,],lwd=2,col=colpal[2])
    lines(times,100*MEGmeantime5Hz[4,],lwd=2,col=colpal[3])
  }
  
  if (plotsmoothed==1){

      spl5aU <- smooth.spline(times,100*(MEGmeantime5Hz[1,]+MEGSEtime5Hz[1,]),df=20)
      spl5aL <- smooth.spline(times,100*(MEGmeantime5Hz[1,]-MEGSEtime5Hz[1,]),df=20)
      polygon(times[c(1:8008,8008:1)],c(spl5aU$y,spl5aL$y[8008:1]),col=colpal[1],border=NA)
      
      spl5cU <- smooth.spline(times,100*(MEGmeantime5Hz[3,]+MEGSEtime5Hz[3,]),df=20)
      spl5cL <- smooth.spline(times,100*(MEGmeantime5Hz[3,]-MEGSEtime5Hz[3,]),df=20)
      polygon(times[c(1:8008,8008:1)],c(spl5cU$y,spl5cL$y[8008:1]),col=colpal[2],border=NA)
      
      spl5dU <- smooth.spline(times,100*(MEGmeantime5Hz[4,]+MEGSEtime5Hz[4,]),df=20)
      spl5dL <- smooth.spline(times,100*(MEGmeantime5Hz[4,]-MEGSEtime5Hz[4,]),df=20)
      polygon(times[c(1:8008,8008:1)],c(spl5dU$y,spl5dL$y[8008:1]),col=colpal[3],border=NA)
 
      spl5a <- smooth.spline(times,100*MEGmeantime5Hz[1,],df=20)
      lines(spl5a$x,spl5a$y,col=colpal[1],lwd=2)
      # spl5b <- smooth.spline(times,MEGmeantime5Hz[2,],df=20)
      # lines(spl5b$x,spl5b$y,col='green',lwd=2)
      spl5c <- smooth.spline(times,100*MEGmeantime5Hz[3,],df=20)
      lines(spl5c$x,spl5c$y,col=colpal[2],lwd=2)
      spl5d <- smooth.spline(times,100*MEGmeantime5Hz[4,],df=20)
      lines(spl5d$x,spl5d$y,col=colpal[3],lwd=2)

  }
  text(6,2.8,'5Hz',cex=2)
  legend(1.25,1,c('Baseline','Monocular','Dichoptic'),lty=1,lwd=2,col=colpal[1:3],box.lwd=2)
  dev.off()
  
  postscript("timecourse2.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
  
  plotlims <- c(-1,7,-3,7)
  ticklocsy <- seq(-3,6,3)    # locations of tick marks on y axis
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklocsx, side = 1, at=ticklocsx)
  mtext(text = c(expression(sqrt(2)/2),'1',expression(sqrt(2)),'2'), side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="Suppression ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  
  polygon(c(0,6,6,0),c(-3.4,-3.4,-2.6,-2.6),border=NA,col=rgb(0.5,0.5,0.5))
  
  lines(c(-1,7),c(0,0),lty=2)
  
  if (plotsmoothed==0){
    polygon(times[c(1:8008,8008:1)],c(MEGmaskindex5[1,]+MEGmaskindexSE5[1,],MEGmaskindex5[1,8008:1]-MEGmaskindexSE5[1,8008:1]),col=colpal[2],border=NA)
    polygon(times[c(1:8008,8008:1)],c(MEGmaskindex5[2,]+MEGmaskindexSE5[2,],MEGmaskindex5[2,8008:1]-MEGmaskindexSE5[2,8008:1]),col=colpal[3],border=NA)
    
    lines(times,MEGmaskindex5[1,],col=colpal[2],lwd=2)
    lines(times,MEGmaskindex5[2,],col=colpal[3],lwd=2)
  }
  if (plotsmoothed==1){
    U <- smooth.spline(times,MEGmaskindex5[1,]+MEGmaskindexSE5[1,],df=20)
    L <- smooth.spline(times,MEGmaskindex5[1,]-MEGmaskindexSE5[1,],df=20)
    U$y[which(U$y<(-3))] <- -3
    L$y[which(L$y<(-3))] <- -3
    polygon(times[c(1:8008,8008:1)],c(U$y,L$y[8008:1]),col=colpal[2],border=NA)
    
    U <- smooth.spline(times,MEGmaskindex5[2,]+MEGmaskindexSE5[2,],df=20)
    L <- smooth.spline(times,MEGmaskindex5[2,]-MEGmaskindexSE5[2,],df=20)
    U$y[which(U$y<(-3))] <- -3
    L$y[which(L$y<(-3))] <- -3
    polygon(times[c(1:8008,8008:1)],c(U$y,L$y[8008:1]),col=colpal[3],border=NA)
    

      L <- smooth.spline(times,MEGmaskindex5[1,],df=20)
      L$y[which(L$y<(-3))] <- -3
      lines(L$x,L$y,col=colpal[2],lwd=2)
      L <- smooth.spline(times,MEGmaskindex5[2,],df=20)
      L$y[which(L$y<(-3))] <- -3
      lines(L$x,L$y,col=colpal[3],lwd=2)

      
  }

  if (nbootstraps>0){
    for (n in 1:clustoutM5$nclusters){
      temp <- unlist(clustoutM5$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-2, -2),lwd=3,col=colpal[2])
    }
        for (n in 1:clustoutD5$nclusters){
      temp <- unlist(clustoutD5$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=3,col=colpal[3])
    }
  }
  
  dev.off()
  
  

  
  postscript("timecourse3.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
  
  plotlims <- c(-1,7,0,3)
  ticklocsy <- seq(0,3,1)    # locations of tick marks on y axis
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklocsx, side = 1, at=ticklocsx)
  mtext(text = ticklocsy, side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="Amplitude", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  
  polygon(c(0,6,6,0),c(-0.11,-0.11,0.15,0.15),border=NA,col=rgb(0.5,0.5,0.5))
  
  if (plotsmoothed==0){
    polygon(times[c(1:8008,8008:1)],100*c(MEGmeantime7Hz[2,]+MEGSEtime7Hz[2,],MEGmeantime7Hz[2,8008:1]-MEGSEtime7Hz[2,8008:1]),col=colpal[1],border=NA)
    polygon(times[c(1:8008,8008:1)],100*c(MEGmeantime7Hz[3,]+MEGSEtime7Hz[3,],MEGmeantime7Hz[3,8008:1]-MEGSEtime7Hz[3,8008:1]),col=colpal[2],border=NA)
    polygon(times[c(1:8008,8008:1)],100*c(MEGmeantime7Hz[4,]+MEGSEtime7Hz[4,],MEGmeantime7Hz[4,8008:1]-MEGSEtime7Hz[4,8008:1]),col=colpal[3],border=NA)
    
    # lines(times,MEGmeantime7Hz[1,],lwd=2,col=colpal[1])
    lines(times,100*MEGmeantime7Hz[2,],lwd=2,col=colpal[1])
    lines(times,100*MEGmeantime7Hz[3,],lwd=2,col=colpal[2])
    lines(times,100*MEGmeantime7Hz[4,],lwd=2,col=colpal[3])
  }
  if (plotsmoothed==1){
    
    spl7bU <- smooth.spline(times,100*(MEGmeantime7Hz[2,]+MEGSEtime7Hz[2,]),df=20)
    spl7bL <- smooth.spline(times,100*(MEGmeantime7Hz[2,]-MEGSEtime7Hz[2,]),df=20)
    polygon(times[c(1:8008,8008:1)],c(spl7bU$y,spl7bL$y[8008:1]),col=colpal[1],border=NA)
    
    spl7cU <- smooth.spline(times,100*(MEGmeantime7Hz[3,]+MEGSEtime7Hz[3,]),df=20)
    spl7cL <- smooth.spline(times,100*(MEGmeantime7Hz[3,]-MEGSEtime7Hz[3,]),df=20)
    polygon(times[c(1:8008,8008:1)],c(spl7cU$y,spl7cL$y[8008:1]),col=colpal[2],border=NA)
    
    spl7dU <- smooth.spline(times,100*(MEGmeantime7Hz[4,]+MEGSEtime7Hz[4,]),df=20)
    spl7dL <- smooth.spline(times,100*(MEGmeantime7Hz[4,]-MEGSEtime7Hz[4,]),df=20)
    polygon(times[c(1:8008,8008:1)],c(spl7dU$y,spl7dL$y[8008:1]),col=colpal[3],border=NA)
    
      spl7b <- smooth.spline(times,100*MEGmeantime7Hz[2,],df=20)
      lines(spl7b$x,spl7b$y,col=colpal[1],lwd=2)
      spl7c <- smooth.spline(times,100*MEGmeantime7Hz[3,],df=20)
      lines(spl7c$x,spl7c$y,col=colpal[2],lwd=2)
      spl7d <- smooth.spline(times,100*MEGmeantime7Hz[4,],df=20)
      lines(spl7d$x,spl7d$y,col=colpal[3],lwd=2)

  }
    text(6,2.8,'7Hz',cex=2)

  dev.off()
  
  postscript("timecourse4.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
  
  plotlims <- c(-1,7,-3,6)
  ticklocsy <- seq(-3,6,3)    # locations of tick marks on y axis
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklocsx, side = 1, at=ticklocsx)
  mtext(text = c(expression(sqrt(2)/2),'1',expression(sqrt(2)),'2'), side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="Suppression ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  
  polygon(c(0,6,6,0),c(-3.4,-3.4,-2.6,-2.6),border=NA,col=rgb(0.5,0.5,0.5))
  
  lines(c(-1,7),c(0,0),lty=2)
  
  if (plotsmoothed==0){
    polygon(times[c(1:8008,8008:1)],c(MEGmaskindex7[1,]+MEGmaskindexSE7[1,],MEGmaskindex7[1,8008:1]-MEGmaskindexSE7[1,8008:1]),col=colpal[2],border=NA)
    polygon(times[c(1:8008,8008:1)],c(MEGmaskindex7[2,]+MEGmaskindexSE7[2,],MEGmaskindex7[2,8008:1]-MEGmaskindexSE7[2,8008:1]),col=colpal[3],border=NA)
    
    lines(times,MEGmaskindex7[1,],col=colpal[2],lwd=2)
    lines(times,MEGmaskindex7[2,],col=colpal[3],lwd=2)
  }
  
  if (plotsmoothed==1){
    U <- smooth.spline(times,MEGmaskindex7[1,]+MEGmaskindexSE7[1,],df=20)
    L <- smooth.spline(times,MEGmaskindex7[1,]-MEGmaskindexSE7[1,],df=20)
    polygon(times[c(1:8008,8008:1)],c(U$y,L$y[8008:1]),col=colpal[2],border=NA)
    
    U <- smooth.spline(times,MEGmaskindex7[2,]+MEGmaskindexSE7[2,],df=20)
    L <- smooth.spline(times,MEGmaskindex7[2,]-MEGmaskindexSE7[2,],df=20)
    polygon(times[c(1:8008,8008:1)],c(U$y,L$y[8008:1]),col=colpal[3],border=NA)
    

      L <- smooth.spline(times,MEGmaskindex7[1,],df=20)
      lines(L$x,L$y,col=colpal[2],lwd=2)
      L <- smooth.spline(times,MEGmaskindex7[2,],df=20)
      lines(L$x,L$y,col=colpal[3],lwd=2)

  }
  
    if (nbootstraps>0){
    for (n in 1:clustoutM7$nclusters){
      temp <- unlist(clustoutM7$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-2, -2),lwd=3,col=colpal[2])
    }
        for (n in 1:clustoutD7$nclusters){
      temp <- unlist(clustoutD7$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=3,col=colpal[3])
    }
    }
  
  dev.off()
  

  
  freqlist <- seq(1/6,20,length=ncol(meanspec))
  
  postscript("spectrum.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 10)
  
  plotlims <- c(0,20,0,4)  # define the x and y limits of the plot (minx,maxx,miny,maxy)
  ticklocsx <- seq(0,20,5)    # locations of tick marks on x axis
  ticklocsy <- c(0,0.4,0.8,1,2,3,4)    # locations of tick marks on y axis
  ticklabelsx <- seq(0,20,5)        # set labels for x ticks
  ticklabelsy <- c(0,0.2,0.4,'','','','')    # set labels for y ticks
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])   
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)     # plot tick marks (no labels)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklabelsx, side = 1, at=ticklocsx)     # add the tick labels
  mtext(text = ticklabelsy, side = 2, at=ticklocsy, line=0.2, las=1) 
  title(xlab="Frequency (Hz)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    # titles for axes
  title(ylab="Amplitude", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  
  lines(c(0,20),c(0,0),lty=3)
  lines(c(0,20),c(1,1),lty=3)
  lines(c(0,20),c(2,2),lty=3)
  lines(c(0,20),c(3,3),lty=3)
  
  polygon(c(1,freqlist[6:120],20),c(0,40*meanspec[1,6:120],0)+3,border=NA,col=colpal[1])
  polygon(c(1,freqlist[6:120],20),c(0,40*meanspec[2,6:120],0)+2,border=NA,col=colpal[1])
  polygon(c(1,freqlist[6:120],20),c(0,40*meanspec[3,6:120],0)+1,border=NA,col=colpal[2])
  polygon(c(1,freqlist[6:120],20),c(0,40*meanspec[4,6:120],0),border=NA,col=colpal[3])
  
  lines(freqlist[6:120],40*meanspec[1,6:120]+3,lwd=2,col='black')
  lines(freqlist[6:120],40*meanspec[2,6:120]+2,lwd=2,col='black')
  lines(freqlist[6:120],40*meanspec[3,6:120]+1,lwd=2,col='black')
  lines(freqlist[6:120],40*meanspec[4,6:120],lwd=2,col='black')
  
  text(20,3.5,'5Hz monocular target',pos=2,cex=1.5)
  text(20,2.5,'7Hz monocular target',pos=2,cex=1.5)
  text(20,1.5,'Monocular combination',pos=2,cex=1.5)
  text(20,0.5,'Dichoptic combination',pos=2,cex=1.5)
  
  dev.off()
  
  
  
  PostScriptTrace(paste('timecourse1.ps',sep=''))
  e6 <- readPicture('timecourse1.ps.xml')
  for (n in 1:length(e6@paths)){
    temp <- class(e6@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e6@paths[n]$path@rgb))<765){e6@paths[n]$path@rgb <- addalpha(e6@paths[n]$path@rgb,alpha=0.2)}}}
  
  PostScriptTrace(paste('timecourse2.ps',sep=''))
  e7 <- readPicture('timecourse2.ps.xml')
  for (n in 1:length(e7@paths)){
    temp <- class(e7@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e7@paths[n]$path@rgb))<765){e7@paths[n]$path@rgb <- addalpha(e7@paths[n]$path@rgb,alpha=0.2)}}}
  
  PostScriptTrace(paste('timecourse3.ps',sep=''))
  e8 <- readPicture('timecourse3.ps.xml')
  for (n in 1:length(e8@paths)){
    temp <- class(e8@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e8@paths[n]$path@rgb))<765){e8@paths[n]$path@rgb <- addalpha(e8@paths[n]$path@rgb,alpha=0.2)}}}
  
  PostScriptTrace(paste('timecourse4.ps',sep=''))
  e9 <- readPicture('timecourse4.ps.xml')
  for (n in 1:length(e9@paths)){
    temp <- class(e9@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e9@paths[n]$path@rgb))<765){e9@paths[n]$path@rgb <- addalpha(e9@paths[n]$path@rgb,alpha=0.2)}}}
  
  PostScriptTrace(paste('spectrum.ps',sep=''))
  e10 <- readPicture('spectrum.ps.xml')
  for (n in 1:length(e10@paths)){
    temp <- class(e10@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e10@paths[n]$path@rgb))<765){e10@paths[n]$path@rgb <- addalpha(e10@paths[n]$path@rgb,alpha=0.2)}}}
  
   if (!file.exists('temp/groupbrainbothSNR.tif')){
      hid <- pmatch('groupbrainbothSNR.tif',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
   }
   if (!file.exists('temp/LH.tif')){
      hid <- pmatch('LH.tif',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
   }
  if (!file.exists('temp/RH.tif')){
      hid <- pmatch('RH.tif',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
   }
  e1 <- readTIFF('temp/groupbrainbothSNR.tif')
  e2 <- readTIFF('temp/LH.tif')
  e3 <- readTIFF('temp/RH.tif')
  
  pdf('Figures/MEGdata.pdf', bg="transparent", height = 6, width = 15)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1)) 
  
  aspratio <- (2500/1600)*(6/15)  # this is the aspect ratio of the output pdf
  imwidth <- 0.5
  xstart <- 0
  ystart <- 0.5
  rasterImage(e1,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)
  
  aspratio <- (1024/682)*(6/15)  # this is the aspect ratio of the output pdf
  imwidth <- 0.25
  xstart <- 0.3
  ystart <- 0.76
  rasterImage(e2,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)
  ystart <- 0.52
  rasterImage(e3,xstart,ystart,xstart+imwidth*aspratio,ystart+imwidth)
  
  grid.picture(e10,x=0.25,y=0.25,width=0.45,height=1)
  
  grid.picture(e6,x=0.6,y=0.75,width=0.25,height=1)
  grid.picture(e7,x=0.85,y=0.75,width=0.25,height=1)
  grid.picture(e8,x=0.6,y=0.25,width=0.25,height=1)
  grid.picture(e9,x=0.85,y=0.25,width=0.25,height=1)
  
  text(-0.02,1,'(a)',pos=4,cex=2)
  text(-0.02,0.45,'(b)',pos=4,cex=2)
  text(0.515,1,'(c)',pos=4,cex=2)
  text(0.515,0.46,'(d)',pos=4,cex=2)
  text(0.785,1,'(e)',pos=4,cex=2)
  text(0.785,0.46,'(f)',pos=4,cex=2)
  
  dev.off()
  
  file.remove(c('timecourse1.ps','timecourse2.ps','timecourse3.ps','timecourse4.ps','spectrum.ps'))
  file.remove(c('timecourse1.ps.xml','timecourse2.ps.xml','timecourse3.ps.xml','timecourse4.ps.xml','spectrum.ps.xml'))
  
}

```

```{r MEGdata, fig.cap="Summary of MEG results for N=20 adults. Panel (a) shows average SSVEP response in source space, thresholded at SNR=2 (blue, left), and locations of the V1 ROI on the medial surface of both hemispheres (right, red). Panel (b) shows the Fourier spectra for the four experimental conditions, from the most responsive vertex in V1. Panels (c,d) show timecourses at 5Hz and 7Hz, and panels (e,f) show suppression ratios for the monocular and dichoptic conditions at each frequency, with points around y = 0.8 indicating a significantly increasing ratio. Shaded regions in panels (c-f) indicate ±1SE across participants, and light grey rectangles indicate the period of stimulus presentation.", fig.align="center", echo=FALSE}

knitr::include_graphics('Figures/MEGdata.pdf')

```

Next we repeated the experiment on 20 participants using a 248-channel whole-head cryogenic MEG system. Half of the participants had a diagnosis of autism, and the remainder were age- and gender-matched controls. Source localisation using a linearly constrained minimum variance (LCMV) beamformer algorithm [@VanVeen1997] showed strong localisation of steady-state signals at the occipital pole (see Figure \@ref(fig:MEGdata)a), and in the Fourier domain (Figure \@ref(fig:MEGdata)b). Responses from the most responsive V1 vertex showed a similar timecourse to those of the EEG experiments at both frequencies (Figure \@ref(fig:MEGdata)c,d), and showed increasing suppression during the first few seconds of stimulus presentation (Figure \@ref(fig:MEGdata)e,f). The normalization reweighting effect was again clearest at 5Hz, especially for the dichoptic condition (red curve in Figure \@ref(fig:MEGdata)e). This confirms that the reweighting effects can occur as early as primary visual cortex, consistent with findings from neurophysiology [@Aschner2018]. However the data are more variable than for our EEG experiments, and had fewer significant clusters, owing to the smaller sample size for this dataset.

```{r include=FALSE, results='hide'}

 if (!file.exists('temp/EEGsummary.RData')){
      hid <- pmatch('EEGsummary.RData',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
 }
load('temp/EEGsummary.RData')

 if (!file.exists('temp/pilotquestionnaire.csv')){
      hid <- pmatch('pilotquestionnaire.csv',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
 }
pilotqdata <- read.csv('temp/pilotquestionnaire.csv')
pilotAQ <- NULL
for (n in 1:101){
  pilotAQ[n] <- scoreAQshort(pilotqdata[n,3:30])
}
pilotAQ <- pilotAQ[-75]

 if (!file.exists('temp/MEGsummary.RData')){
      hid <- pmatch('MEGsummary.RData',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
 }
load("temp/MEGsummary.RData")
MEGAQ <- MEGallAQ[2:20]
MEGgroup <- MEGallDiagnosis[2:20]

MEG_A <- MEGAQ[which(MEGgroup=="Yes")]
MEG_C <- MEGAQ[which(MEGgroup=="No")]
t <- t.test(MEG_A,MEG_C,paired=FALSE)

t_age <- t.test(MEGallAge[which(MEGallDiagnosis=='Yes')],MEGallAge[which(MEGallDiagnosis=='No')],paired=FALSE,var.equal=TRUE)

corMEG <- cor.test(MEGallAQ[2:20],MEGallSPQ[2:20])
corEEG <- cor.test(allAQ,allSPQ)

if (processdata>0){

  postscript('AQplot1.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
  
  plotlims <- c(0,50,0,2)
  ticklocsx <- seq(0,50,10)    # locations of tick marks on y axis
  ticklocsy <- c(0, 2)
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklocsx, side = 1, at=ticklocsx)

  title(xlab="AQ score", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="Pilot experiment", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  
  a <- density(pilotAQ,from=0,to=50)
  a$y <- a$y/max(a$y)
  
  i <- which(a$x<median(pilotAQ))
  polygon(c(0,a$x[c(i,i[length(i)])]),c(0,a$y[i],0),border=NA,col=colpal[4])
  
  i <- which(a$x>median(pilotAQ))
  polygon(a$x[c(i[1],i)],c(0,a$y[i]),border=NA,col=colpal[5])
  
  lines(c(0,a$x),c(0,a$y),lwd=3)
  
  lines(c(median(pilotAQ),median(pilotAQ)),c(0,1.1),lwd=5,col='grey')
  
  temp <- pilotAQ[which(pilotAQ<median(pilotAQ))]
  points(temp,0.5*runif(length(temp))+1.25,col=colpal[4],pch=16)
  
  temp <- pilotAQ[which(pilotAQ>median(pilotAQ))]
  points(temp,0.5*runif(length(temp))+1.25,col=colpal[5],pch=16)
  
  temp <- pilotAQ[which(pilotAQ==median(pilotAQ))]
  points(temp,0.5*runif(length(temp))+1.25,col='grey',pch=16)
  
  dev.off()
  
  
    postscript('AQplot2.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
  
  plotlims <- c(0,50,0,2)
  ticklocsx <- seq(0,50,10)    # locations of tick marks on y axis
  ticklocsy <- c(0, 2)
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklocsx, side = 1, at=ticklocsx)

  title(xlab="AQ score", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="EEG experiment", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    

  a <- density(allAQ,from=0,to=50)
  a$y <- a$y/max(a$y)
  
  i <- which(a$x<median(allAQ))
  polygon(c(0,a$x[c(i,i[length(i)])]),c(0,a$y[i],0),border=NA,col=colpal[4])
  
  i <- which(a$x>median(allAQ))
  polygon(a$x[c(i[1],i)],c(0,a$y[i]),border=NA,col=colpal[5])
  
  lines(c(0,a$x),c(0,a$y),lwd=3)
  
  lines(c(median(allAQ),median(allAQ)),c(0,1.1),lwd=5,col='grey')
  
  temp <- allAQ[which(allAQ<median(allAQ))]
  points(temp,0.5*runif(length(temp))+1.25,col=colpal[4],pch=16)
  
  temp <- allAQ[which(allAQ>median(allAQ))]
  points(temp,0.5*runif(length(temp))+1.25,col=colpal[5],pch=16)
  
  temp <- allAQ[which(allAQ==median(allAQ))]
  points(temp,0.5*runif(length(temp))+1.25,col='grey',pch=16)
  
  dev.off()
  
    postscript('AQplot3.ps', horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
  
  plotlims <- c(0,50,0,2)
  ticklocsx <- seq(0,50,10)    # locations of tick marks on y axis
  ticklocsy <- c(0, 2)
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklocsx, side = 1, at=ticklocsx)

  title(xlab="AQ score", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="MEG experiment", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    

  temp <- MEGAQ[which(MEGgroup=='No')]
  points(temp,0.5*runif(length(temp))+1.25,col=colpal[4],pch=16)
  a <- density(temp,from=0,to=50)
  a$y <- a$y/max(a$y)
  polygon(a$x,a$y,border=NA,col=colpal[4])
  lines(a$x,a$y,lwd=3)
  
  temp <- MEGAQ[which(MEGgroup=='Yes')]
  points(temp,0.5*runif(length(temp))+1.25,col=colpal[5],pch=16)
  a <- density(temp,from=0,to=50)
  a$y <- a$y/max(a$y)
  polygon(c(a$x,50),c(a$y,0),border=NA,col=colpal[5])
  lines(c(a$x,50),c(a$y,0),lwd=3)
  
  dev.off()
  
   if (!file.exists('temp/Pilotsummary.RData')){
      hid <- pmatch('Pilotsummary.RData',as.character(unlist(osffiles[,1])))
      osf_download(osffiles[hid,],'temp/',progress=TRUE)
 }
  load('temp/Pilotsummary.RData')
  
  duration <- 10
  targetF <- 7
  maskF <- 5
  isincluded <- matrix(rep(1,3*dim(EEGspectra)[1]),nrow=3,ncol=dim(EEGspectra)[1])
  for (cond in 1:3){
    # note that in allspec the DC component has been removed
    # so we don't need to add 1 to the index
    tempxy <- data.frame(Re(EEGspectra[,cond,duration*targetF]),Im(EEGspectra[,cond,duration*targetF]))
    D5 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
    tempxy <- data.frame(Re(EEGspectra[,cond,duration*maskF]),Im(EEGspectra[,cond,duration*maskF]))      
    D7 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))      
    isincluded[cond,which(D5>3)] <- 0
    isincluded[cond,which(D7>3)] <- 0
  }
  
  
  medAQp <- median(pilotAQ)
  islowAQp <- rep(0,100)
  ishighAQp <- rep(0,100)
  islowAQp[which(pilotAQ<medAQp)] <- 1
  ishighAQp[which(pilotAQ>medAQp)] <- 1
  
  Pilotmeantime5HzL <- matrix(0,nrow=3,ncol=13000)
  Pilotmeantime7HzL <- matrix(0,nrow=3,ncol=13000)
  Pilotmeantime5HzH <- matrix(0,nrow=3,ncol=13000)
  Pilotmeantime7HzH <- matrix(0,nrow=3,ncol=13000)
  Pilotmeantime10HzL <- matrix(0,nrow=3,ncol=13000)
  Pilotmeantime14HzL <- matrix(0,nrow=3,ncol=13000)
  Pilotmeantime10HzH <- matrix(0,nrow=3,ncol=13000)
  Pilotmeantime14HzH <- matrix(0,nrow=3,ncol=13000)
  
  for (cond in 1:3){
    lowAQincluded <- islowAQp * isincluded[cond,]
    highAQincluded <- ishighAQp * isincluded[cond,]
    
    Pilotmeantime7HzL[cond,] <- apply(abs(EEGtimecourse[which(lowAQincluded==1),1,cond,]),2,mean,na.rm=TRUE)
    Pilotmeantime5HzL[cond,] <- apply(abs(EEGtimecourse[which(lowAQincluded==1),2,cond,]),2,mean,na.rm=TRUE)
    
    Pilotmeantime7HzH[cond,] <- apply(abs(EEGtimecourse[which(highAQincluded==1),1,cond,]),2,mean,na.rm=TRUE)
    Pilotmeantime5HzH[cond,] <- apply(abs(EEGtimecourse[which(highAQincluded==1),2,cond,]),2,mean,na.rm=TRUE)

    Pilotmeantime14HzL[cond,] <- apply(abs(EEGtimecourse[which(lowAQincluded==1),3,cond,]),2,mean,na.rm=TRUE)
    Pilotmeantime10HzL[cond,] <- apply(abs(EEGtimecourse[which(lowAQincluded==1),4,cond,]),2,mean,na.rm=TRUE)
    
    Pilotmeantime14HzH[cond,] <- apply(abs(EEGtimecourse[which(highAQincluded==1),3,cond,]),2,mean,na.rm=TRUE)
    Pilotmeantime10HzH[cond,] <- apply(abs(EEGtimecourse[which(highAQincluded==1),4,cond,]),2,mean,na.rm=TRUE)
    
  }
  

  includedboth <- isincluded[2,]*isincluded[3,]*islowAQp
  monratios1 <- abs(EEGtimecourse[which(includedboth==1),2,2,])/abs(EEGtimecourse[which(includedboth==1),2,3,])
  monratios2 <- abs(EEGtimecourse[which(includedboth==1),1,1,])/abs(EEGtimecourse[which(includedboth==1),1,3,])
  monratios3 <- abs(EEGtimecourse[which(includedboth==1),4,2,])/abs(EEGtimecourse[which(includedboth==1),4,3,])
  monratios4 <- abs(EEGtimecourse[which(includedboth==1),3,1,])/abs(EEGtimecourse[which(includedboth==1),3,3,])
  monratios <- (20*log10(monratios1) + 20*log10(monratios2) + 20*log10(monratios3) + 20*log10(monratios4))/4
  PilotmaskindexL <- colMeans(monratios)
  PilotmaskindexSEL <- apply(monratios,2,sd)/sqrt(sum(includedboth))

  lowgroup <- monratios
  
  includedboth <- isincluded[2,]*isincluded[3,]*ishighAQp
  monratios1 <- abs(EEGtimecourse[which(includedboth==1),2,2,])/abs(EEGtimecourse[which(includedboth==1),2,3,])
  monratios2 <- abs(EEGtimecourse[which(includedboth==1),1,1,])/abs(EEGtimecourse[which(includedboth==1),1,3,])
  monratios3 <- abs(EEGtimecourse[which(includedboth==1),4,2,])/abs(EEGtimecourse[which(includedboth==1),4,3,])
  monratios4 <- abs(EEGtimecourse[which(includedboth==1),3,1,])/abs(EEGtimecourse[which(includedboth==1),3,3,])
  monratios <- (20*log10(monratios1) + 20*log10(monratios2) + 20*log10(monratios3) + 20*log10(monratios4))/4
  PilotmaskindexH <- colMeans(monratios)
  PilotmaskindexSEH <- apply(monratios,2,sd)/sqrt(sum(includedboth))
  
  highgroup <- monratios
  
  Pilotmaskindex5L <- matrix(0,nrow=2,ncol=13000)
  PilotmaskindexSE5L <- matrix(0,nrow=2,ncol=13000)
  includedboth <- isincluded[2,]*isincluded[3,]*islowAQp
  monratios <- abs(EEGtimecourse[which(includedboth==1),2,2,])/abs(EEGtimecourse[which(includedboth==1),2,3,])
  Pilotmaskindex5L[1,] <- colMeans(20*log10(monratios))
  PilotmaskindexSE5L[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  
  Pilotmaskindex5H <- matrix(0,nrow=2,ncol=13000)
  PilotmaskindexSE5H <- matrix(0,nrow=2,ncol=13000)
  includedboth <- isincluded[2,]*isincluded[3,]*ishighAQp
  monratios <- abs(EEGtimecourse[which(includedboth==1),2,2,])/abs(EEGtimecourse[which(includedboth==1),2,3,])
  Pilotmaskindex5H[1,] <- colMeans(20*log10(monratios))
  PilotmaskindexSE5H[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  
  Pilotmaskindex7L <- matrix(0,nrow=2,ncol=13000)
  PilotmaskindexSE7L <- matrix(0,nrow=2,ncol=13000)
  includedboth <- isincluded[1,]*isincluded[3,]*islowAQp
  monratios <- abs(EEGtimecourse[which(includedboth==1),1,1,])/abs(EEGtimecourse[which(includedboth==1),1,3,])
  Pilotmaskindex7L[1,] <- colMeans(20*log10(monratios))
  PilotmaskindexSE7L[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  
  Pilotmaskindex7H <- matrix(0,nrow=2,ncol=13000)
  PilotmaskindexSE7H <- matrix(0,nrow=2,ncol=13000)
  includedboth <- isincluded[1,]*isincluded[3,]*ishighAQp
  monratios <- abs(EEGtimecourse[which(includedboth==1),1,1,])/abs(EEGtimecourse[which(includedboth==1),1,3,])
  Pilotmaskindex7H[1,] <- colMeans(20*log10(monratios))
  PilotmaskindexSE7H[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  
  if (nbootstraps>0){clustout <- clustercorrect(lowgroup,highgroup,paired=FALSE,nresamples=nbootstraps)}
  
  times <- ((1:13000)-1000)/1000
  
  
  postscript("Ptimecourse.ps", horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
  
  plotlims <- c(-1,12,-3,6)
  ticklocsx <- -1:12
  ticklocsy <- seq(-3,6,3)    # locations of tick marks on y axis
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
  axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
  axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
  mtext(text = ticklocsx, side = 1, at=ticklocsx)
  mtext(text = c(expression(sqrt(2)/2),'1',expression(sqrt(2)),'2'), side = 2, at=ticklocsy, line=0.2, las=1)
  title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
  title(ylab="Suppression ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
  
  polygon(c(0,11,11,0),c(-3.4,-3.4,-2.6,-2.6),border=NA,col=rgb(0.5,0.5,0.5))
  
  lines(c(-1,12),c(0,0),lty=2)
  
  if (plotsmoothed==0){
    polygon(times[c(1:13000,13000:1)],c(PilotmaskindexL+PilotmaskindexSEL,PilotmaskindexL[13000:1]-PilotmaskindexSEL[13000:1]),col=colpal[4],border=NA)
    polygon(times[c(1:13000,13000:1)],c(PilotmaskindexH+PilotmaskindexSEH,PilotmaskindexH[13000:1]-PilotmaskindexSEH[13000:1]),col=colpal[5],border=NA)
    
    lines(times,PilotmaskindexL,col=colpal[4],lwd=2)
    lines(times,PilotmaskindexH,col=colpal[5],lwd=2)
  }
  
  if (plotsmoothed==1){
    U <- smooth.spline(times,PilotmaskindexL+PilotmaskindexSEL,df=20)
    L <- smooth.spline(times,PilotmaskindexL-PilotmaskindexSEL,df=20)
    polygon(times[c(1:13000,13000:1)],c(U$y,L$y[13000:1]),col=colpal[4],border=NA)
    
    U <- smooth.spline(times,PilotmaskindexH+PilotmaskindexSEH,df=20)
    L <- smooth.spline(times,PilotmaskindexH-PilotmaskindexSEH,df=20)
    polygon(times[c(1:13000,13000:1)],c(U$y,L$y[13000:1]),col=colpal[5],border=NA)
    
    L <- smooth.spline(times,PilotmaskindexL,df=20)
    lines(L$x,L$y,col=colpal[4],lwd=2)
    L <- smooth.spline(times,PilotmaskindexH,df=20)
    lines(L$x,L$y,col=colpal[5],lwd=2)
  }
  
  if (nbootstraps>0){
    for (n in 1:clustout$nclusters){
      temp <- unlist(clustout$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=3)
    }
    }
    
  dev.off()
  
  
  load('temp/EEGsummary.RData')
  

  duration <- 6
  targetF <- 5
  maskF <- 7
  isincluded <- matrix(rep(1,4*dim(allspec)[1]),nrow=4,ncol=dim(allspec)[1])
  for (cond in 1:4){
    # note that in allspec the DC component has been removed
    # so we don't need to add 1 to the index
    tempxy <- data.frame(Re(allspec[,cond,duration*targetF]),Im(allspec[,cond,duration*targetF]))
    D5 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
    tempxy <- data.frame(Re(allspec[,cond,duration*maskF]),Im(allspec[,cond,duration*maskF]))      
    D7 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))      
    isincluded[cond,which(D5>3)] <- 0
    isincluded[cond,which(D7>3)] <- 0
    for (s in 1:100){
      if (max(abs(EEGtimecourse5Hz[s,cond,]))>5){isincluded[cond,s] <- 0}
    }   
  }
  
    if (useSPQ==1){
    # if this flag is set, we do the median split by SPQ instead of AQ
  medAQ <- median(allSPQ)
  islowAQ <- rep(0,100)
  ishighAQ <- rep(0,100)
  islowAQ[which(allSPQ<medAQ)] <- 1
  ishighAQ[which(allSPQ>medAQ)] <- 1
    }
  if (useSPQ==0){
  medAQ <- median(allAQ)
  islowAQ <- rep(0,100)
  ishighAQ <- rep(0,100)
  islowAQ[which(allAQ<medAQ)] <- 1
  ishighAQ[which(allAQ>medAQ)] <- 1
  }
  
  EEGmeantime5HzL <- matrix(0,nrow=4,ncol=8000)
  EEGmeantime7HzL <- matrix(0,nrow=4,ncol=8000)
  EEGSEtime5HzL <- matrix(0,nrow=4,ncol=8000)
  EEGSEtime7HzL <- matrix(0,nrow=4,ncol=8000)
  EEGmeantime5HzH <- matrix(0,nrow=4,ncol=8000)
  EEGmeantime7HzH <- matrix(0,nrow=4,ncol=8000)
  EEGSEtime5HzH <- matrix(0,nrow=4,ncol=8000)
  EEGSEtime7HzH <- matrix(0,nrow=4,ncol=8000)
  
  for (cond in 1:4){
    lowAQincluded <- islowAQ * isincluded[cond,]
    highAQincluded <- ishighAQ * isincluded[cond,]
    
    EEGmeantime7HzL[cond,] <- apply(abs(EEGtimecourse7Hz[which(lowAQincluded==1),cond,]),2,mean,na.rm=TRUE)
    EEGmeantime5HzL[cond,] <- apply(abs(EEGtimecourse5Hz[which(lowAQincluded==1),cond,]),2,mean,na.rm=TRUE)
    
    EEGSEtime7HzL[cond,] <- apply(abs(EEGtimecourse7Hz[which(lowAQincluded==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(lowAQincluded))
    EEGSEtime5HzL[cond,] <- apply(abs(EEGtimecourse5Hz[which(lowAQincluded==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(lowAQincluded))
    
    EEGmeantime7HzH[cond,] <- apply(abs(EEGtimecourse7Hz[which(highAQincluded==1),cond,]),2,mean,na.rm=TRUE)
    EEGmeantime5HzH[cond,] <- apply(abs(EEGtimecourse5Hz[which(highAQincluded==1),cond,]),2,mean,na.rm=TRUE)
    
    EEGSEtime7HzH[cond,] <- apply(abs(EEGtimecourse7Hz[which(highAQincluded==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(highAQincluded))
    EEGSEtime5HzH[cond,] <- apply(abs(EEGtimecourse5Hz[which(highAQincluded==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(highAQincluded))
  }
 
  
  EEGmaskindexL <- matrix(0,nrow=2,ncol=8000)
  EEGmaskindexSEL <- matrix(0,nrow=2,ncol=8000)
  includedboth <- isincluded[1,]*isincluded[3,]*islowAQ
  monratios1 <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),3,])
  monratios2 <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),3,])
  monratios <- (20*log10(monratios1) + 20*log10(monratios2))/2
  EEGmaskindexL[1,] <- colMeans(monratios)
  EEGmaskindexSEL[1,] <- apply(monratios,2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*islowAQ
  dichratios1 <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),4,])
  dichratios2 <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),4,])
  dichratios <- (20*log10(dichratios1) + 20*log10(dichratios2))/2
  EEGmaskindexL[2,] <- colMeans(dichratios)
  EEGmaskindexSEL[2,] <- apply(dichratios,2,sd)/sqrt(sum(includedboth))
  
  lowgroupM <- monratios
  lowgroupD <- dichratios
  
  EEGmaskindexH <- matrix(0,nrow=2,ncol=8000)
  EEGmaskindexSEH <- matrix(0,nrow=2,ncol=8000)
  includedboth <- isincluded[1,]*isincluded[3,]*ishighAQ
  monratios1 <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),3,])
  monratios2 <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),3,])
  monratios <- (20*log10(monratios1) + 20*log10(monratios2))/2
  EEGmaskindexH[1,] <- colMeans(monratios)
  EEGmaskindexSEH[1,] <- apply(monratios,2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*ishighAQ
  dichratios1 <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),4,])
  dichratios2 <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),4,])
  dichratios <- (20*log10(dichratios1) + 20*log10(dichratios2))/2
  EEGmaskindexH[2,] <- colMeans(dichratios)
  EEGmaskindexSEH[2,] <- apply(dichratios,2,sd)/sqrt(sum(includedboth))
  
  highgroupM <- monratios
  highgroupD <- dichratios
  
  EEGmaskindex5L <- matrix(0,nrow=2,ncol=8000)
  EEGmaskindexSE5L <- matrix(0,nrow=2,ncol=8000)
  includedboth <- isincluded[1,]*isincluded[3,]*islowAQ
  monratios <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),3,])
  EEGmaskindex5L[1,] <- colMeans(20*log10(monratios))
  EEGmaskindexSE5L[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*islowAQ
  dichratios <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),4,])
  EEGmaskindex5L[2,] <- colMeans(20*log10(dichratios))
  EEGmaskindexSE5L[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
  
  EEGmaskindex5H <- matrix(0,nrow=2,ncol=8000)
  EEGmaskindexSE5H <- matrix(0,nrow=2,ncol=8000)
  includedboth <- isincluded[1,]*isincluded[3,]*ishighAQ
  monratios <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),3,])
  EEGmaskindex5H[1,] <- colMeans(20*log10(monratios))
  EEGmaskindexSE5H[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*ishighAQ
  dichratios <- abs(EEGtimecourse5Hz[which(includedboth==1),1,])/abs(EEGtimecourse5Hz[which(includedboth==1),4,])
  EEGmaskindex5H[2,] <- colMeans(20*log10(dichratios))
  EEGmaskindexSE5H[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
  
  EEGmaskindex7L <- matrix(0,nrow=2,ncol=8000)
  EEGmaskindexSE7L <- matrix(0,nrow=2,ncol=8000)
  includedboth <- isincluded[2,]*isincluded[3,]*islowAQ
  monratios <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),3,])
  EEGmaskindex7L[1,] <- colMeans(20*log10(monratios))
  EEGmaskindexSE7L[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[2,]*isincluded[4,]*islowAQ
  dichratios <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),4,])
  EEGmaskindex7L[2,] <- colMeans(20*log10(dichratios))
  EEGmaskindexSE7L[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
  
  EEGmaskindex7H <- matrix(0,nrow=2,ncol=8000)
  EEGmaskindexSE7H <- matrix(0,nrow=2,ncol=8000)
  includedboth <- isincluded[2,]*isincluded[3,]*ishighAQ
  monratios <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),3,])
  EEGmaskindex7H[1,] <- colMeans(20*log10(monratios))
  EEGmaskindexSE7H[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[2,]*isincluded[4,]*ishighAQ
  dichratios <- abs(EEGtimecourse7Hz[which(includedboth==1),2,])/abs(EEGtimecourse7Hz[which(includedboth==1),4,])
  EEGmaskindex7H[2,] <- colMeans(20*log10(dichratios))
  EEGmaskindexSE7H[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
    if (nbootstraps>0){
      clustoutM <- clustercorrect(lowgroupM,highgroupM,paired=FALSE,nresamples=nbootstraps)
      clustoutD <- clustercorrect(lowgroupD,highgroupD,paired=FALSE,nresamples=nbootstraps)    
    }

  times <- ((1:8000)-1000)/1000
  
  for (masktype in 1:2){
    
    
    postscript(paste0("timecourse",masktype,"all.ps"), horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
    
    plotlims <- c(-1,7,-3,6)
    ticklocsx <- -1:7
    ticklocsy <- seq(-3,6,3)    # locations of tick marks on y axis
    plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
    axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
    axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
    mtext(text = ticklocsx, side = 1, at=ticklocsx)
    mtext(text = c(expression(sqrt(2)/2),'1',expression(sqrt(2)),'2'), side = 2, at=ticklocsy, line=0.2, las=1)
    title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
    title(ylab="Suppression ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
    
    polygon(c(0,6,6,0),c(-3.4,-3.4,-2.6,-2.6),border=NA,col=rgb(0.5,0.5,0.5))
    
    lines(c(-1,7),c(0,0),lty=2)
    
    if (plotsmoothed==0){
      polygon(times[c(1:8000,8000:1)],c(EEGmaskindexL[masktype,]+EEGmaskindexSEL[masktype,],EEGmaskindexL[masktype,8000:1]-EEGmaskindexSEL[masktype,8000:1]),col=colpal[4],border=NA)
      polygon(times[c(1:8000,8000:1)],c(EEGmaskindexH[masktype,]+EEGmaskindexSEH[masktype,],EEGmaskindexH[masktype,8000:1]-EEGmaskindexSEH[masktype,8000:1]),col=colpal[5],border=NA)
      
      lines(times,EEGmaskindexL[masktype,],col=colpal[4],lwd=2)
      lines(times,EEGmaskindexH[masktype,],col=colpal[5],lwd=2)
    }
    
    if (plotsmoothed==1){
      U <- smooth.spline(times,EEGmaskindexL[masktype,]+EEGmaskindexSEL[masktype,],df=20)
      L <- smooth.spline(times,EEGmaskindexL[masktype,]-EEGmaskindexSEL[masktype,],df=20)
      polygon(times[c(1:8000,8000:1)],c(U$y,L$y[8000:1]),col=colpal[4],border=NA)
      
      U <- smooth.spline(times,EEGmaskindexH[masktype,]+EEGmaskindexSEH[masktype,],df=20)
      L <- smooth.spline(times,EEGmaskindexH[masktype,]-EEGmaskindexSEH[masktype,],df=20)
      polygon(times[c(1:8000,8000:1)],c(U$y,L$y[8000:1]),col=colpal[5],border=NA)
      
      L <- smooth.spline(times,EEGmaskindexL[masktype,],df=20)
      lines(L$x,L$y,col=colpal[4],lwd=2)
      L <- smooth.spline(times,EEGmaskindexH[masktype,],df=20)
      lines(L$x,L$y,col=colpal[5],lwd=2)
    }
    
          if (nbootstraps>0){
        if (masktype==1){
    for (n in 1:clustoutM$nclusters){
      temp <- unlist(clustoutM$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=2)
    }}
        if (masktype==2){
    for (n in 1:clustoutD$nclusters){
      temp <- unlist(clustoutD$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=2)
    }}   
          }
    
    dev.off()
    
  }
  
  
  load('temp/MEGsummary.RData')
  MEGgroup <- MEGallDiagnosis
  
  MEGmeantime5HzC <- matrix(0,nrow=4,ncol=8008)
  MEGmeantime7HzC <- matrix(0,nrow=4,ncol=8008)
  MEGSEtime5HzC <- matrix(0,nrow=4,ncol=8008)
  MEGSEtime7HzC <- matrix(0,nrow=4,ncol=8008)
  MEGmeantime5HzA <- matrix(0,nrow=4,ncol=8008)
  MEGmeantime7HzA <- matrix(0,nrow=4,ncol=8008)
  MEGSEtime5HzA <- matrix(0,nrow=4,ncol=8008)
  MEGSEtime7HzA <- matrix(0,nrow=4,ncol=8008)
  
  CONindices <- which(MEGgroup=='No')
  ASCindices <- which(MEGgroup=='Yes')
  isCON <- (1:20)*0
  isASC <- (1:20)*0
  isCON[CONindices] <- 1
  isASC[ASCindices] <- 1
  
  duration <- 6
  targetF <- 5
  maskF <- 7
  isincluded <- matrix(rep(1,4*dim(allspec)[1]),nrow=4,ncol=dim(allspec)[1])
  for (cond in 1:4){
    # note that in allspec the DC component has been removed
    # so we don't need to add 1 to the index
    tempxy <- data.frame(Re(allspec[,cond,duration*targetF]),Im(allspec[,cond,duration*targetF]))
    D5 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))
    tempxy <- data.frame(Re(allspec[,cond,duration*maskF]),Im(allspec[,cond,duration*maskF]))      
    D7 <- sqrt(mahalanobis(tempxy,colMeans(tempxy),cov(tempxy)))      
    isincluded[cond,which(D5>3)] <- 0
    isincluded[cond,which(D7>3)] <- 0
  }
  
  
  for (cond in 1:4){
    CONincluded <- isCON * isincluded[cond,]
    ASCincluded <- isASC * isincluded[cond,]
    
    MEGmeantime7HzC[cond,] <- apply(abs(MEGtimecourse7Hz[which(CONincluded==1),cond,]),2,mean,na.rm=TRUE)
    MEGmeantime5HzC[cond,] <- apply(abs(MEGtimecourse5Hz[which(CONincluded==1),cond,]),2,mean,na.rm=TRUE)
    
    MEGSEtime7HzC[cond,] <- apply(abs(MEGtimecourse7Hz[which(CONincluded==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(CONincluded))
    MEGSEtime5HzC[cond,] <- apply(abs(MEGtimecourse5Hz[which(CONincluded==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(CONincluded))
    
    MEGmeantime7HzA[cond,] <- apply(abs(MEGtimecourse7Hz[which(ASCincluded==1),cond,]),2,mean,na.rm=TRUE)
    MEGmeantime5HzA[cond,] <- apply(abs(MEGtimecourse5Hz[which(ASCincluded==1),cond,]),2,mean,na.rm=TRUE)
    
    MEGSEtime7HzA[cond,] <- apply(abs(MEGtimecourse7Hz[which(ASCincluded==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(ASCincluded))
    MEGSEtime5HzA[cond,] <- apply(abs(MEGtimecourse5Hz[which(ASCincluded==1),cond,]),2,sd,na.rm=TRUE)/sqrt(sum(ASCincluded))
  }
  
  MEGmaskindexC <- matrix(0,nrow=2,ncol=8008)
  MEGmaskindexSEC <- matrix(0,nrow=2,ncol=8008)
  includedboth <- isincluded[1,]*isincluded[3,]*isCON
  monratios1 <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),3,])
  monratios2 <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),3,])
  monratios <- (20*log10(monratios1) + 20*log10(monratios2))/2
  MEGmaskindexC[1,] <- colMeans(monratios)
  MEGmaskindexSEC[1,] <- apply(monratios,2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*isCON
  dichratios1 <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),4,])
  dichratios2 <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),4,])
  dichratios <- (20*log10(dichratios1) + 20*log10(dichratios2))/2
  MEGmaskindexC[2,] <- colMeans(dichratios)
  MEGmaskindexSEC[2,] <- apply(dichratios,2,sd)/sqrt(sum(includedboth))
  
  CgroupM <- monratios
  CgroupD <- dichratios
  
  MEGmaskindexA <- matrix(0,nrow=2,ncol=8008)
  MEGmaskindexSEA <- matrix(0,nrow=2,ncol=8008)
  includedboth <- isincluded[1,]*isincluded[3,]*isASC
  monratios1 <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),3,])
  monratios2 <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),3,])
  monratios <- (20*log10(monratios1) + 20*log10(monratios2))/2
  MEGmaskindexA[1,] <- colMeans(monratios)
  MEGmaskindexSEA[1,] <- apply(monratios,2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*isASC
  dichratios1 <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),4,])
  dichratios2 <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),4,])
  dichratios <- (20*log10(dichratios1) + 20*log10(dichratios2))/2
  MEGmaskindexA[2,] <- colMeans(dichratios)
  MEGmaskindexSEA[2,] <- apply(dichratios,2,sd)/sqrt(sum(includedboth))
  
  MEGmaskindexA <- matrix(0,nrow=2,ncol=8008)
  MEGmaskindexSEA <- matrix(0,nrow=2,ncol=8008)
  includedboth <- isincluded[1,]*isincluded[3,]*isASC
  monratios <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),3,])
  MEGmaskindexA[1,] <- colMeans(20*log10(monratios))
  MEGmaskindexSEA[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*isASC
  dichratios <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),4,])
  MEGmaskindexA[2,] <- colMeans(20*log10(dichratios))
  MEGmaskindexSEA[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
  AgroupM <- monratios
  AgroupD <- dichratios
  
  MEGmaskindex5C <- matrix(0,nrow=2,ncol=8008)
  MEGmaskindexSE5C <- matrix(0,nrow=2,ncol=8008)
  includedboth <- isincluded[1,]*isincluded[3,]*isCON
  monratios <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),3,])
  MEGmaskindex5C[1,] <- colMeans(20*log10(monratios))
  MEGmaskindexSE5C[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*isCON
  dichratios <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),4,])
  MEGmaskindex5C[2,] <- colMeans(20*log10(dichratios))
  MEGmaskindexSE5C[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
  
  MEGmaskindex5A <- matrix(0,nrow=2,ncol=8008)
  MEGmaskindexSE5A <- matrix(0,nrow=2,ncol=8008)
  includedboth <- isincluded[1,]*isincluded[3,]*isASC
  monratios <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),3,])
  MEGmaskindex5A[1,] <- colMeans(20*log10(monratios))
  MEGmaskindexSE5A[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[1,]*isincluded[4,]*isASC
  dichratios <- abs(MEGtimecourse5Hz[which(includedboth==1),1,])/abs(MEGtimecourse5Hz[which(includedboth==1),4,])
  MEGmaskindex5A[2,] <- colMeans(20*log10(dichratios))
  MEGmaskindexSE5A[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
  
  MEGmaskindex7C <- matrix(0,nrow=2,ncol=8008)
  MEGmaskindexSE7C <- matrix(0,nrow=2,ncol=8008)
  includedboth <- isincluded[2,]*isincluded[3,]*isCON
  monratios <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),3,])
  MEGmaskindex7C[1,] <- colMeans(20*log10(monratios))
  MEGmaskindexSE7C[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[2,]*isincluded[4,]*isCON
  dichratios <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),4,])
  MEGmaskindex7C[2,] <- colMeans(20*log10(dichratios))
  MEGmaskindexSE7C[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
  
  MEGmaskindex7A <- matrix(0,nrow=2,ncol=8008)
  MEGmaskindexSE7A <- matrix(0,nrow=2,ncol=8008)
  includedboth <- isincluded[2,]*isincluded[3,]*isASC
  monratios <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),3,])
  MEGmaskindex7A[1,] <- colMeans(20*log10(monratios))
  MEGmaskindexSE7A[1,] <- apply(20*log10(monratios),2,sd)/sqrt(sum(includedboth))
  includedboth <- isincluded[2,]*isincluded[4,]*isASC
  dichratios <- abs(MEGtimecourse7Hz[which(includedboth==1),2,])/abs(MEGtimecourse7Hz[which(includedboth==1),4,])
  MEGmaskindex7A[2,] <- colMeans(20*log10(dichratios))
  MEGmaskindexSE7A[2,] <- apply(20*log10(dichratios),2,sd)/sqrt(sum(includedboth))
  
      if (nbootstraps>0){
      clustoutM <- clustercorrect(CgroupM,AgroupM,paired=FALSE,nresamples=nbootstraps)
      clustoutD <- clustercorrect(CgroupD,AgroupD,paired=FALSE,nresamples=nbootstraps)    
    }
  
  times <- ((1:8008)-1001)/1001
  
  for (masktype in 1:2){
    
    postscript(paste0("MEGtimecourse",masktype,"a.ps"), horizontal = FALSE, onefile = FALSE, paper = "special", height = 5, width = 5)
    
    plotlims <- c(-1,7,-3,6)
    ticklocsx <- -1:7
    ticklocsy <- seq(-3,6,3)    # locations of tick marks on y axis
    plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=plotlims[1:2], ylim=plotlims[3:4])
    axis(1, at=ticklocsx, tck=0.01, lab=F, lwd=2)
    axis(2, at=ticklocsy, tck=0.01, lab=F, lwd=2)
    mtext(text = ticklocsx, side = 1, at=ticklocsx)
    mtext(text = c(expression(sqrt(2)/2),'1',expression(sqrt(2)),'2'), side = 2, at=ticklocsy, line=0.2, las=1)
    title(xlab="Time (s)", col.lab=rgb(0,0,0), line=1.2, cex.lab=1.5)    
    title(ylab="Suppression ratio", col.lab=rgb(0,0,0), line=1.5, cex.lab=1.5)
    
    polygon(c(0,6,6,0),c(-3.4,-3.4,-2.6,-2.6),border=NA,col=rgb(0.5,0.5,0.5))
    
    lines(c(-1,7),c(0,0),lty=2)
    
    if (plotsmoothed==0){
      polygon(times[c(1:8008,8008:1)],c(MEGmaskindexC[masktype,]+MEGmaskindexSEC[masktype,],MEGmaskindexC[masktype,8008:1]-MEGmaskindexSEC[masktype,8008:1]),col=colpal[4],border=NA)
      polygon(times[c(1:8008,8008:1)],c(MEGmaskindexA[masktype,]+MEGmaskindexSEA[masktype,],MEGmaskindexA[masktype,8008:1]-MEGmaskindexSEA[masktype,8008:1]),col=colpal[5],border=NA)
      
      lines(times,MEGmaskindexC[masktype,],col=colpal[4],lwd=2)
      lines(times,MEGmaskindexA[masktype,],col=colpal[5],lwd=2)
    }
    
    if (plotsmoothed==1){
      U <- smooth.spline(times,MEGmaskindexC[masktype,]+MEGmaskindexSEC[masktype,],df=20)
      L <- smooth.spline(times,MEGmaskindexC[masktype,]-MEGmaskindexSEC[masktype,],df=20)
      U$y[which(U$y<(-3))] <- -3
      L$y[which(L$y<(-3))] <- -3
      U$y[which(U$y>6)] <- 6
      L$y[which(L$y>6)] <- 6
      polygon(times[c(1:8008,8008:1)],c(U$y,L$y[8008:1]),col=colpal[4],border=NA)
      
      U <- smooth.spline(times,MEGmaskindexA[masktype,]+MEGmaskindexSEA[masktype,],df=20)
      L <- smooth.spline(times,MEGmaskindexA[masktype,]-MEGmaskindexSEA[masktype,],df=20)
      U$y[which(U$y<(-3))] <- -3
      L$y[which(L$y<(-3))] <- -3
      U$y[which(U$y>6)] <- 6
      L$y[which(L$y>6)] <- 6
      polygon(times[c(1:8008,8008:1)],c(U$y,L$y[8008:1]),col=colpal[5],border=NA)
      
      L <- smooth.spline(times,MEGmaskindexC[masktype,],df=20)
      L$y[which(L$y<(-3))] <- -3
      L$y[which(L$y>6)] <- 6
      lines(L$x,L$y,col=colpal[4],lwd=2)
      L <- smooth.spline(times,MEGmaskindexA[masktype,],df=20)
      L$y[which(L$y<(-3))] <- -3
      L$y[which(L$y>6)] <- 6
      lines(L$x,L$y,col=colpal[5],lwd=2)
    }
    
      if (nbootstraps>0){
        if (masktype==1){
    for (n in 1:clustoutM$nclusters){
      temp <- unlist(clustoutM$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=2)
    }}
        if (masktype==2){
    for (n in 1:clustoutD$nclusters){
      temp <- unlist(clustoutD$clusterpoints[n])
      lines(times[temp[c(1,length(temp))]],c(-1.5, -1.5),lwd=2)
    }}   
      }
    
    dev.off()    
    
  }

  
  PostScriptTrace(paste('AQplot1.ps',sep=''))
  e1a <- readPicture('AQplot1.ps.xml')
  for (n in 1:length(e1a@paths)){
    temp <- class(e1a@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e1a@paths[n]$path@rgb))<765){e1a@paths[n]$path@rgb <- addalpha(e1a@paths[n]$path@rgb,alpha=0.2)}}}
  
    PostScriptTrace(paste('AQplot2.ps',sep=''))
  e1b <- readPicture('AQplot2.ps.xml')
  for (n in 1:length(e1b@paths)){
    temp <- class(e1b@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e1b@paths[n]$path@rgb))<765){e1b@paths[n]$path@rgb <- addalpha(e1b@paths[n]$path@rgb,alpha=0.2)}}}

    PostScriptTrace(paste('AQplot3.ps',sep=''))
  e1c <- readPicture('AQplot3.ps.xml')
  for (n in 1:length(e1c@paths)){
    temp <- class(e1c@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e1c@paths[n]$path@rgb))<765){e1c@paths[n]$path@rgb <- addalpha(e1c@paths[n]$path@rgb,alpha=0.2)}}}


  PostScriptTrace(paste('Ptimecourse.ps',sep=''))
  e2a <- readPicture('Ptimecourse.ps.xml')
  for (n in 1:length(e2a@paths)){
    temp <- class(e2a@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e2a@paths[n]$path@rgb))<765){e2a@paths[n]$path@rgb <- addalpha(e2a@paths[n]$path@rgb,alpha=0.2)}}}
  
  PostScriptTrace(paste('timecourse1all.ps',sep=''))
  e4 <- readPicture('timecourse1all.ps.xml')
  for (n in 1:length(e4@paths)){
    temp <- class(e4@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e4@paths[n]$path@rgb))<765){e4@paths[n]$path@rgb <- addalpha(e4@paths[n]$path@rgb,alpha=0.2)}}}

  PostScriptTrace(paste('timecourse2all.ps',sep=''))
  e5 <- readPicture('timecourse2all.ps.xml')
  for (n in 1:length(e5@paths)){
    temp <- class(e5@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e5@paths[n]$path@rgb))<765){e5@paths[n]$path@rgb <- addalpha(e5@paths[n]$path@rgb,alpha=0.2)}}}
  

  PostScriptTrace(paste('MEGtimecourse1a.ps',sep=''))
  e8 <- readPicture('MEGtimecourse1a.ps.xml')
  for (n in 1:length(e8@paths)){
    temp <- class(e8@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e8@paths[n]$path@rgb))<765){e8@paths[n]$path@rgb <- addalpha(e8@paths[n]$path@rgb,alpha=0.2)}}}
  
  PostScriptTrace(paste('MEGtimecourse2a.ps',sep=''))
  e9 <- readPicture('MEGtimecourse2a.ps.xml')
  for (n in 1:length(e9@paths)){
    temp <- class(e9@paths[n]$path)[1]
    if (pmatch(temp,"PictureFill",nomatch=0)){
      if (sum(col2rgb(e9@paths[n]$path@rgb))<765){e9@paths[n]$path@rgb <- addalpha(e9@paths[n]$path@rgb,alpha=0.2)}}}
  
  
  pdf('Figures/AQfigure.pdf', bg="transparent", height = 10, width = 12)
  par(mar=c(0.1,0.1,0.1,0.1))
  plot(x=NULL,y=NULL,axes=FALSE, ann=FALSE, xlim=c(0,1), ylim=c(0,1))
  
  grid.picture(e1a,x=1/6,y=5/6,width=0.33,height=1)
  grid.picture(e1b,x=1/6,y=3/6,width=0.33,height=1)
  grid.picture(e1c,x=1/6,y=1/6,width=0.33,height=1)
  
  grid.picture(e2a,x=3/6,y=5/6,width=0.33,height=1)
  grid.picture(e4,x=3/6,y=3/6,width=0.33,height=1)
  grid.picture(e5,x=5/6,y=3/6,width=0.33,height=1)
  grid.picture(e8,x=3/6,y=1/6,width=0.33,height=1)
  grid.picture(e9,x=5/6,y=1/6,width=0.33,height=1)

  text(0.01,1,'(a)',pos=4,cex=2)
  text(0.01,0.64,'(b)',pos=4,cex=2)
  text(0.01,0.28,'(c)',pos=4,cex=2)
  text(0.375,1,'(d)',pos=4,cex=2)
  text(0.375,0.64,'(e)',pos=4,cex=2)
  text(0.735,0.64,'(f)',pos=4,cex=2)
  text(0.375,0.28,'(g)',pos=4,cex=2)
  text(0.735,0.28,'(h)',pos=4,cex=2)

  text(0.47,1,'Binocular',pos=4,cex=1.5)
  text(0.47,0.64,'Monocular',pos=4,cex=1.5)
  text(0.83,0.64,'Dichoptic',pos=4,cex=1.5)
  text(0.47,0.28,'Monocular',pos=4,cex=1.5)
  text(0.83,0.28,'Dichoptic',pos=4,cex=1.5)
  
  
  legend(0.78,0.9,c('Low AQ/control','High AQ/autism'), lwd=4,col=colpal[4:5],bty='n')

  dev.off()
  
  file.remove(c('AQplot1.ps','AQplot2.ps','AQplot3.ps'))
  file.remove(c('AQplot1.ps.xml','AQplot2.ps.xml','AQplot3.ps.xml'))
  file.remove(c('Ptimecourse.ps','Ptimecourse.ps.xml'))
  file.remove(c('timecourse1all.ps','timecourse1all.ps.xml'))
  file.remove(c('timecourse2all.ps','timecourse2all.ps.xml'))
  file.remove(c('MEGtimecourse1a.ps','MEGtimecourse1a.ps.xml'))
  file.remove(c('MEGtimecourse2a.ps','MEGtimecourse2a.ps.xml'))
              
  
}

```

```{r AQanalysis, fig.cap="Analysis of the effect of autistic traits on normalization reweighting. Panels (a-c) show distributions of AQ scores across the three data sets. Panels (d-h) show timecourses of suppression averaged across stimulation frequency, and split by AQ score (d-f) or autism status (g, h). Panels (d,e,g) are for binocular or monocular presentation, and panels (f,h) are for dichoptic presentation. Shaded regions in panels (d-h) indicate ±1SE across participants, and black points at y = 0.8 indicate significant differences between groups.", fig.align="center", fig.width=0.5, echo=FALSE}

knitr::include_graphics('Figures/AQfigure.pdf')

```

To investigate whether normalization reweighting effects differ with respect to autistic traits, we then split each dataset (averaged across temporal frequency) using median AQ score (for the EEG experiments) or according to diagnostic group (autism vs controls) for the MEG data. Figure \@ref(fig:AQanalysis)a-c shows distributions of AQ scores for each experiment, and indicates for the pilot and EEG data which participants were in the high (purple) and low (green) AQ groups. The median AQ scores were `r round(median(pilotAQ),digits=0)` for the pilot data, and `r median(allAQ)` for the EEG data. In the MEG experiment, AQ scores for the autism group (mean `r round(mean(MEG_A),digits=1)`) and the control group (mean `r round(mean(MEG_C),digits=1)`) were significantly different (*t* = `r format(round(t$statistic,digits=2),nsmall=2)`, *df* = `r round(t$parameter,digits=1)`, *p* < 0.001), with minimal overlap (one participant with an autism diagnosis had an AQ score marginally lower than the highest AQ scores from the control group). These distributions are consistent with previous results for AQ [@Baron-Cohen2001].

We compared the timecourse of suppression between groups using a nonparametric cluster correction approach [@Maris2007] to control the type I error rate. Significant clusters are indicated at y = 0.8 in panels d-h of Figure \@ref(fig:AQanalysis). Despite some occasionally significant clusters, there is no clear or consistent difference between groups across our three data sets. In particular, none of the significant clusters occur during the first few seconds of stimulus onset, when reweighting takes place. We also compared suppression ratios calculated on Fourier components for the full trial, and found no significant effects of autism on suppression strength. We therefore conclude that autism/AQ score is not associated with normalization reweighting, or the strength of suppression more generally.

# Discussion

We found evidence of dynamic normalization reweighting across three separate datasets. Suppression increased significantly during the first 2-5 seconds of stimulus presentation, though with some variation across temporal frequency. Reweighting had a similar timecourse for monocular and dichoptic stimulus presentation, and was apparent as early as V1. We did not find compelling differences associated with autism, or high vs low autistic traits. In the remainder of this section we will discuss possible explanations for temporal frequency differences, evidence for inhibitory differences in autism, and more general implications of dynamic normalization reweighting.

One important question is whether the dynamic increase in suppression can be explained by the stimulus onset transient. This is a possibility that cannot be ruled out for some of our data. For example, the steep increase in suppression in Figure \@ref(fig:EEGdata)f has a similar timecourse to the onset transient in Figure \@ref(fig:EEGdata)d. However, there are also counterexamples where suppression continues to increase well beyond the first 1 second of stimulus presentation (e.g. Figure \@ref(fig:EEGdata)e). It is currently unclear why there appear to be such substantial differences between temporal frequency conditions, especially with such similar frequencies (5 and 7Hz). However the differences are relatively consistent across experiments. For example, 5Hz flicker produces a more gradual increase in suppression across all three data sets, compared with 7Hz flicker. These differences may be a consequence of visual channels with different temporal tuning interacting with the stimulation frequency, as well as any nonlinearities that govern suppression. Or there could be an asymmetry, whereby the relative temporal frequency between the two stimulus components affects the character of suppression [@Liza2022]. We hope to be able to model these effects in the future, for example by using dynamic models of early vision that incorporate time-lagged gain control [e.g. @Zhou2019].

We did not observe clear differences in the timecourse between monocular and dichoptic suppression. This is important, because the dichoptic arrangement bypasses early stages of processing before the cortex (e.g. the retina and lateral geniculate nucleus). It suggests that the dynamic increases in suppression occur in the cortex, consistent with our MEG data that find evidence of reweighting in V1 (see Fig \@ref(fig:MEGdata)), and with previous neurophysiological work [@Aschner2018]. It is currently unclear whether these effects originate in V1, or might involve feedback from higher areas. The similarity between monocular and dichoptic effects also differs from work on adaptation to individual mask components. In both physiological [@Li2005; @Sengpiel2005] and psychophysical [@Baker2007] paradigms, adapting to a dichoptic mask reduces its potency, whereas adapting to a monocular mask has little or no effect. Normalization reweighting offers an explanation for why monocular masks presented in isolation do not adapt: if suppressive weights are determined by co-occurrence of stimuli, presentation of an isolated mask will have little effect. However this cannot explain the dichoptic adaptation effects without invoking additional binocular processes, such as competition between summing and differencing channels [e.g. @May2012].

The relationship between normalization reweighting and other forms of visual plasticity is currently unclear. One phenomenon that might be closely related to our dichoptic effect is the change in interocular suppression that occurs when one eye is patched for a period of time [@Lunghi2011]. In the patching paradigm, the inputs to the two eyes are uncorrelated while one eye is patched, which the normalization reweighting model predicts should reduce suppression between the eyes. Most studies using patching have focussed on the resulting imbalance between the patched and non-patched eye, in which the patched eye contributes more to binocular single vision than the non-patched eye. In principle this could be due to increased suppression of the non-patched eye (inconsistent with normalization reweighting), or reduced suppression of the patched eye (consistent with normalization reweighting). It is difficult to distinguish these possibilities using paradigms that assess the balance between the two eyes, such as the binocular rivalry paradigm from the original @Lunghi2011 study. However subsequent work has shown that patching increases the patched eye's response [@Zhou2015], and reduces both dichoptic masking [@Baldwin2018] and levels of the inhibitory neurotransmitter GABA [@Lunghi2015]. All of these findings are consistent with a reweighting account.

Participants in Experiments 2 & 3 also completed the sensory perception quotient (SPQ) scale. SPQ scores showed significant negative correlation with AQ for both data sets (EEG data, *r* = `r round(corEEG$estimate,digits=2)`, *p* < `r ceiling(1000*corEEG$p.value)/1000`; MEG data, *r* = `r round(corMEG$estimate,digits=2)`, *p* = `r round(corMEG$p.value,digits=3)`) with effect sizes comparable to those reported previously [@Tavassoli2014]. We also conducted an exploratory analysis of the EEG data from Experiment 2, splitting participants by SPQ instead of AQ. However this analysis did not reveal any convincing differences in normalization reweighting either. Our preregistration also proposed to replicate our earlier finding of a reduced second harmonic response in participants with autism/high AQ scores. However the changes to the experimental design greatly reduced the second harmonic response in both experiments, such that it could not be observed reliably (see Figures \@ref(fig:EEGdata)b and \@ref(fig:MEGdata)b). We were therefore not confident in conducting this analysis. We suspect that the increase in spatial frequency from 0.5 c/deg in the @Vilidaite2018 study to 2 c/deg here is most likely responsible for the dramatically reduced second harmonic response.

The idea that the dynamic balance of inhibition and excitation might be different in autism [@Rubenstein2003; @Rosenberg2015] has compelling face validity. For example individuals with autism often report difficulties with changes in their sensory environment, which might be due to gain control processes failing to adapt appropriately. Indeed, there is experimental evidence of reduced adaptation across various domains [@Pellicano2007; @Turi2015], which is predicted by some autism models [@Pellicano2012]. However this appears not to extend to changes in normalization reweighting, despite the link between reweighting and adaptation [@Westrick2016].

## Conclusions

We investigated the timecourse of normalization reweighting across three datasets, with a total of 220 participants. We found clear evidence that suppression increases during the first 2-5 seconds of stimulus presentation, though there were differences across frequency that are currently unexplained. We did not find evidence of autism-related differences in either the magnitude or timecourse of suppression. Our results support an emerging theory that suppression is a dynamic process that allows sensory systems to recalibrate according to their recent history.

# Methods

## Participants

Experiment 1 was completed by 100 adult participants (32 male, 68 female; mean age 21.9) in early 2015, and first reported by @Vilidaite2018. Here we reanalysed the dataset, and report the results of masking conditions not previously published. Experiment 2 was completed by 100 adult participants (23 male, 74 female, 3 other/not stated; mean age 22.1) in early 2022. Experiment 3 was completed by 10 adults (2 male, 8 female) with a clinical diagnosis of autism, and 10 control participants who were closely matched for age (means of `r t_age$estimate[1]` and `r t_age$estimate[2]`, *t* = `r format(round(abs(t_age$statistic),digits=2))`, *df* = `r t_age$parameter`, *p* = `r format(round(abs(t_age$p.value),digits=2))`) and exactly matched for gender. Procedures in Experiments 1 and 2 were approved by the ethics committee of the Department of Psychology at the University of York. Procedures for Experiment 3 were approved by the ethics committee of the York Neuroimaging Centre. All participants provided written informed consent.

## Apparatus and stimuli

In Experiments 1 and 2, stimuli were presented using a ViewPixx 3D LCD display device (VPixx Technologies, Canada) with a resolution of 1920 $\times$ 1080 pixels and a refresh rate of 120Hz. The display was gamma corrected using a Minolta LS110 photometer. In Experiment 2, participants wore active stereo shutter glasses (NVidia 3D Vision 2) that were synchronised with the display using an infra-red signal. EEG data were collected using a 64-channel Waveguard cap, and were amplified and digitised at 1000Hz using an ANT Neuroscan system. Electrode impedance was maintained below 5k$\Omega$, and referenced to a whole-head average.

In Experiment 3, stimuli were presented using a ProPixx DLP projector (VPixx Technologies) running at 120Hz. Stereo presentation was enabled using a circular polariser that was synchronised with the projector refresh, and participants wore passive polarised glasses during the experiment. DLP projectors are perfectly linear, so gamma correction was not required. Data were acquired using a refurbished 248-channel 4D Neuroimaging Magnes 3600 MEG scanner, recording at 1001Hz. Participant head shape was digitised using a Polhemus Fastrak device, and head position was recorded at the start and end of each block by passing current through 5 position coils placed at fiducial points on the head. We also obtained structural MRI scans using a 3 Tesla Siemens Magnetom Prisma scanner to aid in source localisation. Two participants were not available for MRI scans, so we used the MNI ICBM152 template brain [@Fonov2011] for these individuals.

Stimuli were patches of sine wave grating with a diameter of 2 degrees, flickering sinusoidally (on/off flicker) at either 5Hz or 7Hz. In Experiment 1 the gratings had a spatial frequency of 0.5c/deg, and in Experiments 2 & 3 this was increased to 2c/deg. A symmetrical array of 36 individual patches tiled the display. In Experiment 1 the patch orientation was randomly selected on each trial, and all patches had the same orientation. In Experiments 2 & 3 each patch had a random orientation, which was intended to prevent any sequential effects between trials with similar orientations. The central patch was omitted and replaced by a fixation marker constructed from randomly overlaid squares. During each experiment, the fixation marker could be resampled on each trial with a probability of 0.5. Participants were instructed to monitor the fixation marker and count the number of times it changed throughout the experiment. This was intended to maintain attention towards the display and keep participants occupied.

Participants also completed either the short AQ [@Hoekstra2011] in Experiment 1, or the full AQ [@Baron-Cohen2001] in Experiments 2 and 3. For comparison across experiments, we rescaled the short AQ to the same range as the full AQ (0-50). In Experiments 2 and 3, the sensory perception quotient (SPQ) questionnaire [@Tavassoli2014] was also completed. 

## Procedures

In Experiment 1, target stimuli flickering at 7Hz were presented at a range of contrasts (1 - 64%). In half of the conditions a superimposed orthogonal mask of 32% contrast was presented simultaneously, flickering at 5Hz. Stimuli were displayed for trials of 11 seconds, with a 3 second inter-trial interval. The experiment consisted of 4 blocks of trials, each lasting around 10 minutes, and resulting in 8 repetitions of each condition. Participants viewed the display from 57cm, were comfortably seated in an upright position, and were able to rest between blocks. Low latency 8-bit digital triggers transmitted the trial onset and condition information directly to the EEG amplifier.

The procedure for Experiment 2 was very similar, except that participants also wore stereo shutter glasses during the experiment. There were four conditions: (i) monocular presentation of a 5Hz stimulus of 48% contrast, (ii) monocular presentation of a 7Hz stimulus of 48% contrast, (iii) monocular presentation of both stimuli superimposed at right angles, and (iv) dichoptic presentation of both stimuli at right angles (i.e. one stimulus to the left eye, one to the right eye). Eye of presentation was pseudo-randomised to ensure equal numbers of left-eye and right-eye presentations. The trial duration was 6 seconds, with a 3 second inter-trial interval. Participants completed 3 blocks, each lasting around 10 minutes, resulting in a total of 48 repetitions of each condition. Experiment 3 was identical, except that the projector screen was viewed from a distance of 85cm.

## Data analysis

EEG data from Experiments 1 and 2 were first imported into Matlab using components of the EEGlab toolbox [@Delorme2004], and converted into a compressed ASCII format. Primary data analysis was then conducted using a bespoke _R_ script. In brief, we epoched each trial and extracted the average timecourse across four occipital electrodes (\emph{Oz}, \emph{POz}, \emph{O1} and \emph{O2}), and then calculated the Fourier transform of this average waveform. We excluded trials for which the Mahalanobis distance of the complex Fourier components exceeded 3 [for details see @Baker2021]. This resulted in `r round(Pilotpercentexcluded,digits=2)`% of trials being excluded for Experiment 1, and `r round(EEGpercentexcluded,digits=2)`% of trials for Experiment 2. Next we averaged the waveforms across all remaining trials, and calculated the Fourier transform in a 1-second sliding window to generate timecourses for each participant. We divided the timecourse for the target-only condition by the timecourse for the target + mask condition to produce a suppression ratio. These were then converted to logarithmic (dB) units for averaging, calculation of standard errors, and statistical comparisons. For display purposes we smoothed the timecourses using a cubic spline function, however all statistical comparisons used the unsmoothed data.

For Experiment 3, we performed source localisation using a linearly constrained minimum variance (LCMV) beamformer algorithm, implemented in Brainstorm [@Tadel2011]. Structural MRI scans were processed using Freesurfer [@Dale1999] to generate a 3D mesh of the head and brain, and we calculated source weights for each block with reference to a 5-minute empty room recording, usually recorded on the day of the experiment. The matrix of source weights for each block was used in a custom Matlab script to extract signals from V1, identified using the probabilistic maps of @Wang2015. These signals were then imported into R for the main analysis, which was consistent with the EEG analysis described above. The outlier rejection procedure excluded `r round(MEGpercentexcluded,digits=2)`% of trials for Experiment 3.

To make comparisons between groups of participants across time, we used a non-parametric cluster correction technique [@Maris2007] based on t-tests. Clusters were identified as temporally adjacent observations that were all statistically significant, and a summed t-value was calculated for each cluster. A null distribution was then generated by randomising group membership and recalculating the summed t-value for the largest cluster, and repeating this procedure `r nbootstraps` times. Clusters were considered significant if they fell outside of the 95% confidence limits of the null distribution. We adapted this approach to test for significantly increasing suppression by conducting one-way t-tests between time points separated by `r timeoffset`ms, and repeating the cluster correction procedure as described above.

## Preregistration, data and code availability

Following a preliminary analysis of the data from Experiment 1, we preregistered our hypotheses and analysis plan for Experiments 2 and 3 on the Open Science Framework website. The preregistration document, along with raw and processed data, and analysis scripts, are publicly available at the project repository: https://osf.io/ab3yv/

# Acknowledgements

Supported by BBSRC grant BB/V007580/1 awarded to DHB and ARW. We are grateful to all of the participants who took part in the experiments reported here.

# References
